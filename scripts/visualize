#! /usr/bin/python
#coding=UTF-8
#
# Copyright Â© 2015 Richard Kettlewell.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import cairo,pango,pangocairo
from datetime import date

class Backup(object):
    """Representation of a single backup"""
    def __init__(self,host,volume,device,time,status):
        self.host=host
        self.volume=volume
        self.device=device
        self.time=time
        self.status=status

class Backups(object):
    """Representation of all backups"""
    def __init__(self, db="/home/richard/backups.db"):
        """Load the list of backups

        Arguments:
        db -- database path
        """
        self.db=db
        self.conn=None
        self.font=pango.FontDescription("sans 10")
        self.xpad=8
        self.ypad=2
        self.background_color=(1,1,1)
        self.foreground_color=(0,0,0)
        self.stripe_color=(0.96875,0.96875,0.96875)
        self.stripe_for='month'
        self.volume_guide_color=(0.9375,0.9375,0.9375)
        self.host_guide_color=(0.875,0.875,0.875)
        self.device_colors=[(1,0,0),
                            (0,1,0),
                            (0,0.125,1),
                            (1,0,1),
                            (1,1,0.25)]
        self.day_width=4
        self.device_indicator_height=2
        self.device_key_indicator_width=16
        self._retrieve()

    # Backup loading and analysis

    def _conn(self):
        """Return a connection to the database"""
        if self.conn is None:
            import sqlite3
            self.conn=sqlite3.connect(self.db)
        return self.conn

    def _retrieve(self):
        """Load self up with complete backups

        Initializes:
        backups -- the list of backups, in no particular order"""
        c=self._conn().cursor()
        backups=[]
        for row in c.execute(
                "SELECT host,volume,device,time,status FROM backup"):
            backup=Backup(*tuple(row))
            if backup.status==2:
                backups.append(backup)
        self.backups=backups

    def _ranges(self):
        """Analyse backups

        Initializes:
        hv_list -- list of host:volume names in order
        hv_to_row -- dict mapping host:volume to a row number (from 0)
        device_list -- list of devices in order
        device_to_index -- dict mapping device to a color number (from 0)
        """
        hv_dict={}
        device_dict={}
        for backup in self.backups:
            hv_dict["%s:%s" % (backup.host, backup.volume)] = True
            device_dict[backup.device]=True
        # TODO also, volumes from config, so we can see things with no
        # backups
        # Put volumes into a coherent order
        self.hv_list=list(hv_dict.keys())
        self.hv_list.sort()
        # Map volume identification to row number
        row=0
        self.hv_to_row={}
        for hv in self.hv_list:
            self.hv_to_row[hv]=row
            row+=1
        # Map device names to an index
        self.device_list=list(device_dict.keys())
        self.device_list.sort()
        device_index=0
        self.device_to_index={}
        for device in self.device_list:
            self.device_to_index[device]=device_index
            device_index+=1

    # Text handling

    def _text_extent(self, c, t):
        """Return text extents

        Arguments:
        c -- cairo context
        t -- text to analyze

        Returns ink, logical where each is (x,y,w,h)."""
        layout=c.create_layout()
        layout.set_text(t)
        layout.set_font_description(self.font)
        return layout.get_pixel_extents()

    def _text(self, c, x, y, t):
        """Render text

        Arguments:
        c -- cairo context
        x -- top left x coordinate
        y -- top left y coordinate
        t -- text to render

        Returns text extents as ink, logical where each is (x,y,w,h)."""
        layout=c.create_layout()
        layout.set_text(t)
        layout.set_font_description(self.font)
        c.move_to(x, y)
        c.show_layout(layout)
        return layout.get_pixel_extents()

    def _extents_row_labels(self, c):
        """Calculate row label extents

        Arguments:
        c -- cairo context

        Initializes:
        host_width -- width of the host labels
        volume_width -- width of the volume labels
        row_height -- height of a row
        """
        self.host_width=0
        self.volume_width=0
        self.row_height=len(self.device_to_index)*self.device_indicator_height
        for hv in self.hv_list:
            host,volume=hv.split(':')
            i,l=self._text_extent(c, host)
            if l[2] > self.host_width: self.host_width=l[2]
            if l[3] > self.row_height: self.row_height=l[3]
            i,l=self._text_extent(c, volume)
            if l[2] > self.volume_width: self.volume_width=l[2]
            if l[3] > self.row_height: self.row_height=l[3]
        self.host_width+=self.xpad
        self.volume_width+=self.xpad
        self.row_height+=self.ypad

    def _extents_rows(self, c):
        """Calculate row layout extents

        Arguments:
        c -- cairo context

        Initializes:
        min_ordinal -- earliest day number
        max_ordinal -- latest day numer
        date_label_height -- height of date labels
        row_width -- total width of rows
        rows_height -- total height of row layout
        """
        self.min_ordinal=0xFFFFFFFFFFFFFFFF
        self.max_ordinal=0
        self.date_label_height=0
        for backup in self.backups:
            d=date.fromtimestamp(backup.time)
            o=d.toordinal()
            if o < self.min_ordinal: self.min_ordinal=o
            if o > self.max_ordinal: self.max_ordinal=o
            # This overdelivers slightly - we aren't actually going to use
            # all these labels.
            i,l=self._text_extent(c, d.isoformat())
            if l[3] > self.date_label_height: self.date_label_height=l[3]
        self.days=self.max_ordinal - self.min_ordinal+1
        self.row_width=self.day_width*self.days
        self.rows_height=len(self.hv_to_row)*self.row_height

    def _extents_device_key(self, c):
        """Calculate device key extents

        Arguments:
        c -- cairo context

        Initializes:
        max_device_width -- maximum width of a device name
        max_device_height -- maximum height of a device name
        device_key_width -- width of device key
        device_key_height -- height of device key
        """
        self.max_device_width=0
        self.max_device_height=0
        for device in self.device_list:
            i,l=self._text_extent(c, device)
            if l[2] > self.max_device_width: self.max_device_width=l[2]
            if l[3] > self.max_device_height: self.max_device_height=l[3]
        self.device_key_width=(self.max_device_width
                               + self.xpad
                               + self.device_key_indicator_width)
        self.device_key_height=self.max_device_height * len(self.device_list)

    def _extents_total(self, c):
        """Calculate total extents

        Arguments:
        c -- cairo context

        Initializes:
        days_start -- x coordinate of the first day's column
        device_key_x -- top left of device key
        device_key_y -- top left of device key
        total_width -- image width
        total_height -- image height
        """
        self.days_start=self.host_width+self.volume_width
        self.total_width=self.days_start+self.row_width
        self.device_key_x=self.total_width-self.device_key_width
        self.device_key_y=(self.rows_height+self.ypad
                           +self.date_label_height+self.ypad)
        self.total_height=self.device_key_y+self.device_key_height

    def _render_background(self, c):
        """Render the background

        Arguments:
        c -- cairo context"""
        c.rectangle(0,0,self.total_width,self.total_height)
        c.set_source_rgb(*self.background_color)
        c.fill()

    def _render_row_labels(self, c):
        """Render the row labels

        Also renders horizontal guides, which is a bit out of place
        but it's convenient to do here.

        Arguments:
        c -- cairo context"""
        row=0
        last_host=""
        for hv in self.hv_list:
            host,volume=hv.split(':')
            y=row * self.row_height
            c.set_source_rgb(*self.foreground_color)
            self._text(c, self.host_width, y, volume)
            if host != last_host:
                self._text(c, 0, row * self.row_height, host)
                c.set_source_rgb(*self.host_guide_color)
            else:
                c.set_source_rgb(*self.volume_guide_color)
            c.rectangle(self.days_start, y-1,
                        self.row_width, 1)
            c.fill()
            row+=1
            last_host=host

    def _render_date_bars(self, c):
        """Render the date bars

        Arguments:
        c -- cairo context"""
        c.set_source_rgb(*self.stripe_color)
        if self.stripe_for=='day':
            self._render_day_bars(c)
        else:
            self._render_month_bars(c)
        c.fill()

    def _render_day_bars(self, c):
        x=self.host_width+self.volume_width
        for o in range(self.min_ordinal, self.max_ordinal+1, 2):
            c.rectangle(x,0,self.day_width,self.rows_height)
            x+=self.day_width*2

    def _render_month_bars(self, c):
        x=self.host_width+self.volume_width
        o=self.min_ordinal
        start_x=x
        start_m=None
        sequence=0
        while o <= self.max_ordinal:
            d=date.fromordinal(o)
            m=d.year*12+d.month-1
            if start_m is None:
                start_m=m
                start_x=x
            if m!=start_m:
                if sequence%2 == 0:
                    c.rectangle(start_x,0,
                                x-start_x,
                                self.rows_height)
                sequence+=1
                start_m=m
                start_x=x
            x+=self.day_width
            o+=1
        if sequence%2 == 0:
            c.rectangle(start_x,0,
                        x-start_x,
                        self.rows_height)
            
    def _render_date_labels(self, c):
        """Render the date labels

        Arguments:
        c -- cairo context"""
        c.set_source_rgb(*self.foreground_color)
        if self.stripe_for=='day':
            self._render_day_labels(c)
        else:
            self._render_month_labels(c)

    def _render_day_labels(self, c):
        x=self.host_width+self.volume_width
        y=self.rows_height+self.ypad
        limit=self.total_width
        for o in range(self.max_ordinal, self.min_ordinal-1, -1):
            x=self.days_start+(o-self.min_ordinal)*self.day_width
            if x <= limit:
                d=date.fromordinal(o)
                i,e=self._text_extent(c, d.isoformat())
                w=e[2]
                self._text(c, x-w+self.day_width, y, d.isoformat())
                c.rectangle(x, y-self.ypad,
                            self.day_width, self.ypad)
                c.fill()
                limit=x-w-self.xpad

    def _render_month_labels(self, c):
        y=self.rows_height+self.ypad
        year=0
        for o in range(self.min_ordinal, self.max_ordinal+1):
            d=date.fromordinal(o)
            if d.day==1:
                x=self.days_start+(o-self.min_ordinal)*self.day_width
                if d.year==year:
                    # Full month mostly
                    t=d.strftime("%B")
                else:
                    # Short month + year for a new year
                    t=d.strftime("%b %Y")
                    year=d.year
                i,e=self._text_extent(c, t)
                w=e[2]
                if x+w > self.total_width:
                    # Doesn't fit, back off to short month name
                    t=d.strftime("%b")
                    i,e=self._text_extent(c, t)
                    w=e[2]
                if x+w > self.total_width:
                    # Still doesn't fit, just push it left
                    x=self.total_width-w
                self._text(c, x, y, t)
                
    def _render_backups(self, c):
        """Render the date backups

        Arguments:
        c -- cairo context"""
        offset=int((self.row_height
                    -self.device_indicator_height*len(self.device_list))/2)
        for backup in self.backups:
            row=self.hv_to_row["%s:%s" % (backup.host, backup.volume)]
            col=date.fromtimestamp(backup.time).toordinal()-self.min_ordinal
            device_index=self.device_to_index[backup.device]
            c.set_source_rgb(*self.device_colors[device_index])
            c.rectangle(self.days_start+col*self.day_width,
                        row*self.row_height+offset+device_index*self.device_indicator_height,
                        self.day_width,
                        self.device_indicator_height)
            c.fill()

    def _render_device_key(self, c):
        """Render the device key

        Arguments:
        c -- cairo context"""
        device_index=0
        for device_index in range(0,len(self.device_list)):
            device=self.device_list[device_index]
            y=self.device_key_y+device_index*self.max_device_height
            c.set_source_rgb(*self.foreground_color)
            self._text(c, self.device_key_x, y, device)
            c.set_source_rgb(*self.device_colors[device_index])
            y+=int((self.max_device_height-self.device_indicator_height)/2)
            c.rectangle(self.device_key_x+self.max_device_width+self.xpad, y,
                        self.device_key_indicator_width, self.device_indicator_height)
            c.fill()

    def render(self, c, render=True):
        """Render the entire layout to a surface

        Arguments:
        c -- cairo context
        render -- True to render, False to just calculate extents

        Returns:
        width, height -- Size of layout"""
        self._ranges()
        self._extents_row_labels(c)
        self._extents_rows(c)
        self._extents_device_key(c)
        self._extents_total(c)
        if render:
            self._render_background(c)
            self._render_date_bars(c)
            self._render_row_labels(c)
            self._render_date_labels(c)
            self._render_backups(c)
            self._render_device_key(c)
        return self.total_width, self.total_height

    def render_fitted_image(self):
        """Construct an appropriately size surface and render to that

        Arguments:
        c -- cairo context"""
        s=cairo.ImageSurface(cairo.FORMAT_ARGB32, 640, 480)
        c=pangocairo.CairoContext(cairo.Context(s))
        w,h=backups.render(c, render=False)
        s=cairo.ImageSurface(cairo.FORMAT_ARGB32, w, h)
        c=pangocairo.CairoContext(cairo.Context(s))
        backups.render(c, render=True)
        return s

if __name__ == '__main__':
    backups=Backups()
    surface=backups.render_fitted_image()
    surface.write_to_png("rsbackup.png") # TODO
