#! /usr/bin/perl -w
#
# Copyright Â© 2010 Richard Kettlewell
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
#
use strict;
use POSIX;
use IO::File;
use Time::Local;
use Data::Dumper;

=head1 NAME

rsbackup - rsync-based backup utility

=head1 SYNOPSIS

B<rsbackup> [OPTIONS] [HOST ...|HOST:VOLUME...]

=head1 DESCRIPTION

Backs up files from one or more (remote) destinations to a single
backup storage directory, preserving their contents, layout,
ownership, permissions, timestamps and hardlink structure.

=cut

our $store;                     # where to store backups
our $config = "/etc/rsbackup.conf"; # config file
our %hosts = ();                # per-host configuration
our $verbose = 0;               # verbose mode
our $debug = 0;
our $act = 1;                   # act (i.e. opposite of --dry-run)
our $private = 1;               # backups are private
our $test;                      # test before backing up
our $html;                      # HTML output
our $backup = 0;                # make a backup
our $prune = 0;                 # prune old backups
our $prune_incomplete = 0;      # prune incompete backups
our $errors = 0;                # number of errors
our $logs = "/var/log/backup";  # log directory
our $minbackups = 3;            # minimum backups to be comfortable
our $maxage = 3;                # maximum age to be comfortable
our $pruneage = 366;            # age at which backups may be pruned
our $sshtimeout = 3;            # SSH timeout to check host is up
our $css = "body {
  color: black;
  background-color: white
}

a:link, a:visited, a:active {
  color: blue;
  text-decoration: underline
}

h1 {
  background-color: #e0ffe0
}

h2 {
  background-color: #e0e0e0
}

table {
  border-collapse: collapse
}

th {
  background-color: #e0e0e0;
  border-left: 1px solid #e0e0e0;
  border-top: 1px solid #e0e0e0;
  border-right: 1px solid #e0e0e0
}

td {
  border: 1px solid black;
  vertical-align: top;
  padding-left: 4px;
  padding-right: 4px
}

td.bad {
  background-color: #ff0000;
  color: #ffffff
}

td.good {
  background-color: #e0ffe0;
  color: #000000
}

pre.log {
  background-color: #f0f0f0
}

div.volume {
  margin-left: 1em
}
";

sub make_dir($) {
    my $dir = shift;
    if(!-d $dir) {
        print STDERR "mkdir $dir\n" if $verbose;
        if($act) {
            mkdir($dir) or die "ERROR: mkdir $dir: $!\n";
        }
    }
}

sub split_line($) {
    local $_ = shift;
    my @s = ();
    while(!/^$/) {
        if(/^\s+(.*)/) {
            $_ = $1;
            next;
        }
        if(/^([^\"\\\s]+)(.*)/) {
            push(@s, $1);
            $_ = $2;
            next;
        }
        if(/^\"((?:[^\"\\]|\\[\"\\])+)\"(.*)/) {
            my $quoted = $1;
            $_ = $2;
            $quoted =~ s/\\(.)/$1/g;
            push(@s, $quoted);
            next;
        }
        die "syntax error\n";
    }
    return @s;
}

# Convert YYYY-MM-DD into a day number
sub day_number {
    my ($y, $m, $d);
    if(scalar @_ == 3) {
        ($y, $m, $d) = @_;
    } else {
        ($y, $m, $d) = split(/-/, $_[0]);
    }
    my $t = timegm(0, 0, 0, $d, $m - 1, $y - 1900);
    return $t / 86400;
}

=head1 OPTIONS

=head2 Action Options

At least one of these options must be specified.  When multiple
actions are specified, they are executed in the order shown below.

=over

=item B<--backup>

Make a backup of the selected volumes.

=item B<--prune>

Prune old backups of selected volumes.

=item B<--prune-incomplete>

Prune incomplete backups of selected volumes.

=item B<--html> PATH

Write an HTML report.  The report covers all volumes, not just
selected ones.

=back

=head2 General Options

=over

=item B<--config> PATH

The path to the configuration file.  The default is
I</etc/rsbackup.conf>.

=item B<--store> PATH

The path to the directory to store backups.  This option overrides the
setting in the configuration file.

=item B<--verbose>

Enable verbose mode.  Various messages will be displayed to report
progress and the rsync B<--quiet> option is suppressed.

=item B<--dry-run>

Enable dry-run mode.  Commands will be displayed but nothing will
actually be done.

This affects the B<--backup>, B<--prune> and B<--prune-incomplete>
options.

=item B<--help>

Display a usage message.

=back

=head2 Volume Selection

If no hosts or volumes are specified on the command line then all
volumes are selected.

If a host is specified on the command line then all volumes for that
host are selected.

If a host:volume pair is specified on the command line then that volume
is selected.

=cut

# Parse command-line options
while(@ARGV > 0 && $ARGV[0] =~ /^-/) {
    local $_ = shift;

    if($_ eq "--store") {
        $store = shift;
    } elsif($_ eq "--config") {
        $config = shift;
    } elsif($_ eq "--verbose") {
        $verbose = 1;
    } elsif($_ eq "--debug") {
        $debug = 1;
    } elsif($_ eq "--html") {
        $html = shift;
    } elsif($_ eq "--backup") {
        $backup = 1;
    } elsif($_ eq "--prune") {
        $prune = 1;
    } elsif($_ eq "--prune-incomplete") {
        $prune_incomplete = 1;
    } elsif($_ eq "--dry-run") {
        $act = 0;
        $verbose = 1;
    } elsif($_ eq "--") {
        last;
    } elsif($_ eq "--help") {
        print <<EOF;
Usage:
  rsbackup [OPTIONS] [HOST...] [HOST:VOLUME...]

Options:
  --store DIR         Override directory to store backups in
  --config PATH       Set config file (/etc/rsbackup.conf)
  --dry-run           Dry run only
  --verbose           Verbose output
  --backup            Make a backup
  --html PATH         Write an HTML report
  --prune             Prune old backups
  --prune-incomplete  Prune incomplete backups
  --help              Display usage message

If no volumes are specified then all volumes in the config file are backed up.
Otherwise the specified volumes are backed up.
EOF
        exit 0;
    } else {
        die "ERROR: unknown option: '$_'\n";
    }
}

if(!$backup
   and !defined $html
   and !$prune
   and !$prune_incomplete) {
    die "ERROR: no action specified\n";
}

=head1 CONFIG FILE

The config file contains global directives and a series of host
stanzas.  Each host stanze in turn contains host directives and volume
stanzas.  Although it is not enforced it is suggested that host and
volume stanzas are indented.

Comments are introduced by an initial "#".

Command arguments may be quoted, using "double quotes".  Quotes and
backslashes within quoted strings are escaped with backslashes.

=head2 Global Directives

=over

=item B<store> PATH

The path to the directory to store backups.  This directive may be
overriden on the command line.

=item B<public>

The store is public.  Normally the store must only be accessible by
the calling user.  This option suppresses the check.

=item B<test> COMMAND

The shell command to test whether to proceed.  If the command fails
(exits nonzero) then the backup will be aborted.

For instance this could be used to test for the presence of a
particular file, to avoid the backup being taken if the backup device
is not mounted.

=item B<logs> PATH

The directory to store logfiles.  The default is I</var/log/backup>.

=item B<ssh-timeout> SECONDS

How long to wait before concluding a host is down.  The default is 3.

=item B<max-age> DAYS

The maximum age of the most recent backup before you feel
uncomfortable.  The default is 3, meaning that if a volume hasn't been
backed up in the last 3 days it will have red ink in the HTML report.

=item B<min-backups> COUNT

The minimum number of backups you feel comfortable with.  The default
is 3, meaning that if a volume has less than 3 backups it will have
red ink in the HTML report.

Pruning will never reduce the number of backups below B<min-backups>.

=item B<prune-age> DAYS

The age at which a backup may be pruned.  The default is 366, meaning
a backup will never be pruned until it is at least a whole year old.

=back

=head2 Host Directives

A host stanza is started by a B<host> directive.  It contains other
host directives, and one or more volume stanzas.

=over

=item B<host> HOST

Introduce a host stanza.  The name is used for the backup directory
for this host.

=item B<hostname> HOSTNAME

The SSH hostname for this host.  The default is the name from the host
stanza.

The hostname "localhost" is treated specially: it is assumed to always
be identical to the local system, so files will be read from the local
filesystem.

=item B<user> USERNAME

The SSH username for this host.  The default is not to supply a
username.

=back

In addition, B<prune-age>, B<min-backups> and B<max-age> can be used
within a host stanza, and apply to just that host.

=head2 Volume Directives

A volume stanza is started by a B<volume> directive.  It contains one
or more volume directives.

=over

=item B<volume> VOLUME PATH

Introduce a volume stanza.  The name is used for the backup directory
for this volume.  The path is the absolute path on the host.

=item B<exclude> PATTERN

An exclusion for this volume.  The pattern is passed to the rsync
B<--exclude> option.  This directive may appear multiple times per
volume.

See the rsync man page for full details.

=item B<traverse>

Traverse mount points.  This suppresses the rsync B<--one-file-system>
option.

=back

In addition, B<prune-age>, B<min-backups> and B<max-age> can be used
within a volume stanza, and apply to just that volume.

=cut

# Read config file
open(CONFIG, "<$config") or die "$config: $!\n";
my $host;
my $volume;
my $line = 0;
while(defined($_ = <CONFIG>)) {
    ++$line;
    chomp;
    next if /^#/;
    my @s;
    eval {
        @s = split_line($_);
    };
    die "$config:$line: $@" if $@;
    next if !@s;
    my $cmd = shift @s;
    if($cmd eq 'host') {
        $host = $s[0];
        die "$config:$line: invalid hostname '$host'\n" 
            unless $host =~ /^[a-z0-9\-\.]+$/i;
        $hosts{$host} = {
            "volumes" => {},
            "minbackups" => $minbackups,
            "maxage" => $maxage,
            "pruneage" => $pruneage,
            "selected" => 0,
        } unless exists $hosts{$host};
    } elsif($cmd eq 'user') {
        die "$config:$line: user command with no preceding host command\n"
            unless defined $host;
        my $user = $s[0];
        $hosts{$host}->{"user"} = $user;
    } elsif($cmd eq 'hostname') {
        die "$config:$line: hostname command with no preceding host command\n"
            unless defined $host;
        my $hostname = $s[0];
        $hosts{$host}->{"hostname"} = $hostname;
    } elsif($cmd eq 'volume') {
        die "$config:$line: volume command with no preceding host command\n"
            unless defined $host;
        $volume = $s[0];
        die "$config:$line: invalid volume name '$volume'\n" 
            unless $volume =~ /^[a-z0-9\-\.]+$/i;
        my $path = $s[1];
        $hosts{$host}->{volumes}->{$volume} =
            {
                "path" => $path,
                "exclude" => [],
                "minbackups" => $hosts{$host}->{minbackups},
                "maxage" => $hosts{$host}->{maxage},
                "pruneage" => $hosts{$host}->{pruneage},
                "selected" => 0,
            };
    } elsif($cmd eq 'exclude') {
        die "$config:$line: store command with no preceding volume command\n"
            unless defined $volume;
        push(@{$hosts{$host}->{volumes}->{$volume}->{exclude}}, $s[0]);
    } elsif($cmd eq 'traverse') {
        die "$config:$line: traverse command with no preceding volume command\n"
            unless defined $volume;
        $hosts{$host}->{volumes}->{$volume}->{traverse} = 1;
    } elsif($cmd eq 'store') {
        $store = $s[0] unless defined $store;
    } elsif($cmd eq 'logs') {
        $logs = $s[0];
    } elsif($cmd eq 'ssh-timeout') {
        $sshtimeout = $s[0];
    } elsif($cmd eq 'public') {
        $private = 0;
    } elsif($cmd eq 'min-backups') {
        if(defined $volume) {
            $hosts{$host}->{volumes}->{$volume}->{minbackups} = $s[0];
        } elsif(defined $host) {
            $hosts{$host}->{minbackups} = $s[0];
        } else {
            $minbackups = $s[0];
        }
    } elsif($cmd eq 'prune-age') {
        if(defined $volume) {
            $hosts{$host}->{volumes}->{$volume}->{pruneage} = $s[0];
        } elsif(defined $host) {
            $hosts{$host}->{pruneage} = $s[0];
        } else {
            $pruneage = $s[0];
        }
    } elsif($cmd eq 'max-age') {
        if(defined $volume) {
            $hosts{$host}->{volumes}->{$volume}->{maxage} = $s[0];
        } elsif(defined $host) {
            $hosts{$host}->{maxage} = $s[0];
        } else {
            $maxage = $s[0];
        }
    } elsif($cmd eq 'test') {
        $test = $s[0];
    } else {
        die "$config:$line: unknown config command '$cmd'\n";
    }
}
close CONFIG;

for my $host (keys %hosts) {
    my %volumes = %{$hosts{$host}->{volumes}};
    if(!%volumes) {
        die "ERROR: host $host has no volumes\n";
    }
}

# Determine which volumes are selected
if(scalar @ARGV) {
    for my $key (@ARGV) {
        if($key =~ /(.*):(.*)/) {
            my $host = $1;
            my $volume = $2;
            if(!exists $hosts{$host}) {
                die "ERROR: host '$host' does not exist\n";
            }
            my $hostdata = $hosts{$host};
            if(!exists $hostdata->{volumes}->{$volume}) {
                die "ERROR: volume '$host:$volume' does not exist\n";
            }
            my $volumedata = $hostdata->{volumes}->{$volume};
            $volumedata->{selected} = 1;
        } else {
            if(!exists $hosts{$key}) {
                die "ERROR: host '$key' does not exist\n";
            }
            my $hostdata = $hosts{$key};
            for my $volume (keys %{$hostdata->{volumes}}) {
                my $volumedata = $hostdata->{volumes}->{$volume};
                $volumedata->{selected} = 1;
            }
        }
    }
} else {
    for my $host (keys %hosts) {
        my $hostdata = $hosts{$host};
        for my $volume (keys %{$hostdata->{volumes}}) {
            my $volumedata = $hostdata->{volumes}->{$volume};
            $volumedata->{selected} = 1;
        }
    }
}

for my $host (keys %hosts) {
    my $hostdata = $hosts{$host};
    $hostdata->{selected} = 0;
    for my $volume (keys %{$hostdata->{volumes}}) {
        my $volumedata = $hostdata->{volumes}->{$volume};
        if($volumedata->{selected}) {
            $hostdata->{selected} = 1;
            last;
        }
    }
}

print STDERR Data::Dumper->Dump([\%hosts], ["hosts"])
    if $debug;

# Backup store had better exist
die "ERROR: $store is not a directory\n" if !-d $store;

# Today's date
my $today = strftime("%Y-%m-%d", localtime);

if($backup) {
    # Make sure log directory exists
    make_dir($logs);

    if($private) {
        # Ensure that backup store is owned by us and not readable
        # or writable by anyone else.
        my @s = stat $store;
        if(!-o $store
           || ($s[2] & 077)) {
            system("ls -ld \Q$store\E >&2");
            die "ERROR: unsuitable directory permissions\n";
        }
    }

    if(defined $test) {
        my $rc = system("cd \Q$store\E && $test");
        if($rc) {
            die "ERROR: test failed: '$test'\n";
        }
    }

    # Perform backups
    for my $host (sort keys %hosts) {
        my $hostdata = $hosts{$host};
        next unless $hostdata->{selected};
        print "=== Backing up $host\n" if $verbose;
        # Figure out user@host
        my $hostname = $hostdata->{"hostname"} || $host;
        my $userhost = $hostname;
        $userhost = "$hostdata->{'/user'}@$hostname" 
            if exists $hostdata->{"user"};
        my $prefix = "$userhost:";
        $prefix = '' if $userhost eq 'localhost';
        # If the host is not reachable then we won't be able to back
        # it up
        if($prefix ne '') {
            my $rc = system("ssh", "-oConnectTimeout=$sshtimeout", $userhost, "true");
            if($rc != 0) {
                print STDERR "$host is not reachable\n\n" if $verbose;
                next;
            }
        }
        make_dir("$store/$host");
        make_dir("$store/$host/$today");
        print STDERR "\n" if $verbose;
        for my $volume (sort keys %{$hostdata->{volumes}}) {
            my $volumedata = $hostdata->{volumes}->{$volume};
            next unless $volumedata->{selected};
            my $path = $volumedata->{path};
            my $storepath = "$store/$host/$today/$volume";
            my $flagpath = "$storepath.incomplete";
            # If the backup directories exists and the flag path does not
            # then we have a complete backup for today already.
            if(-d $storepath and ! -e $flagpath) {
                print STDERR "==== Backup for $host:$volume already complete\n\n"
                    if $verbose;
                next;
            }
            print "==== Backing up $host:$volume $path\n" if $verbose;
            # Create the flag path and then the backup directory.
            if($act) {
                open(O, ">$flagpath") or die "ERROR: creating $flagpath: $!\n";
                close O;
            }
            make_dir("$store/$host/$today/$volume");
            # Base command
            my @cmd = ("rsync",
                       "--archive",
                       "--sparse",
                       "--numeric-ids",
                       "--compress",
                       "--fuzzy",
                       "--hard-links");
            # Options
            push(@cmd, "--quiet") unless $verbose;
            push(@cmd, "--one-file-system") unless $volumedata->{traverse};
            my @exclude = @{$volumedata->{exclude}};
            push(@cmd, map("--exclude=$_", @exclude));
            # Link to old versions if available
            my @old = glob("$store/$host/*/$volume");
            push(@cmd, map("--link-dest=$_/.", @old));
            # Figure out where to rsync from
            push(@cmd, "$prefix$volumedata->{path}/.");
            # Where to rsync to
            push(@cmd, "$store/$host/$today/$volume/.");
            print STDERR join(" ", @cmd), "\n" if $verbose;
            # Do the backup
            if($act) {
                my $logfile = "$logs/$today-$host-$volume.log";
                my $pid = fork();
                die "ERROR: fork: $!\n" if !defined $pid;
                if($pid == 0) {
                    open(STDOUT, ">$logfile") 
                        or die "ERROR: $logfile: $!\n";
                    open(STDERR, ">&STDOUT")
                        or die "ERROR: redirecting stderr: $!\n";
                    exec(@cmd);
                    die "ERROR: executing $cmd[0] failed\n";
                }
                my $w = wait;
                die "ERROR: wait returned wrong PID $w ($!)\n" if $w != $pid;
                my $rc = $?;
                # Include status in logfile
                if($rc) {
                    (open(LOG, ">>$logfile")
                     and printf LOG "ERROR: rsync returned wait status %#x\n", $rc
                     and close LOG)
                        or die "ERROR: $logfile: $!\n";
                } else {
                    (open(LOG, ">>$logfile")
                     and printf LOG "OK\n"
                     and close LOG)
                        or die "ERROR: $logfile: $!\n";
                }
                if($verbose) {
                    # In verbose mode, display the rsync output
                    if(-e $logfile) {
                        system("cat \Q$logfile\E >&2");
                    }
                }
                if($rc) {
                    # On error leave the flag path in place so a
                    # subsequent run knows to retry the backup
                    printf STDERR "ERROR: rsync returned wait status status #%x\n", $rc
                        unless $verbose;
                    ++$errors;
                } else {
                    # On success delete the flag path so a subsequent run
                    # leaves alone.
                    unlink $flagpath;
                }
            }
            print STDERR "\n" if $verbose;
        }
    }
}

if($prune or $prune_incomplete) {
    my $prunelog = "$logs/prune.log";
    if($act) {
        open(LOG, ">>$prunelog") or die "ERROR: $prunelog: $!\n";
        autoflush LOG 1;
    }
    for my $host (sort keys %hosts) {
        my $hostdata = $hosts{$host};
        next unless $hostdata->{selected};
        print "=== Pruning $host\n" if $verbose;
        for my $volume (sort keys %{$hostdata->{volumes}}) {
            my $volumedata = $hostdata->{volumes}->{$volume};
            next unless $volumedata->{selected};
            my $path = $volumedata->{path};
            my $pruneage = $volumedata->{pruneage};
            print "==== Pruning $host:$volume $path (keep for $pruneage days)\n"
                if $verbose;
            my @backups = glob("$store/$host/*/$volume");
            # Identify backups older than the prune age
            my @old_backups = ();
            my %why = ();
            if($prune) {
                for my $b (@backups) {
                    my @s = split(/\//, $b);
                    my $bdate = $s[$#s - 1];
                    if(day_number($bdate) < day_number($today) - $pruneage) {
                        push(@old_backups, $b);
                    }
                }
                # Put them into order
                @old_backups = sort @old_backups;
                # Figure out if we need to keep any to satisfy minbackups
                my $nbackups = scalar @backups;
                my $nleft = $nbackups - scalar @old_backups;
                while(@old_backups > 0 and $nleft < $volumedata->{minbackups}) {
                    my $b = pop @old_backups;
                    my @s = split(/\//, $b);
                    my $bdate = $s[$#s - 1];
                    print STDERR "WARNING: $bdate is old enough, but not enough backups\n"
                        if $verbose;
                    ++$nleft;
                }
                for my $b (@old_backups) {
                    $why{$b} = "more than $pruneage days old";
                }
            }
            # Add in any incomplete backups
            if($prune_incomplete) {
                for my $b (@backups) {
                    next if exists $why{$b};
                    if(-e "$b.incomplete") {
                        push(@old_backups, $b);
                        $why{$b} = "incomplete";
                    }
                }
            }
            # Delete the results
            for my $b (@old_backups) {
                my @s = split(/\//, $b);
                my $bdate = $s[$#s - 1];
                for my $f ($b,
                           "$b.incomplete",
                           "$logs/$bdate-$host-$volume.log") {
                    if(-e $f) {
                        my @cmd = ("rm", "-rf",  $f);
                        print STDERR join(" ", @cmd), "\n" if $verbose;
                        if($act) {
                            my $rc = system(@cmd);
                            if($rc) {
                                print LOG "$today: $b: $why{$b}: FAILED\n"
                                    or die "ERROR: $prunelog: $!\n";
                                die "ERROR: rm failed\n";
                            } else {
                                print LOG "$today: $b: $why{$b}\n"
                                    or die "ERROR: $prunelog: $!\n";
                            }
                        }
                    }
                }
            }
        }
    }
    close LOG if $act;
}

if(defined $html) {
    my %results = ();           # result strings for each backup
    my %logfiles = ();          # logfiles for failed backups
    my $today_number = day_number($today);
    for my $file (glob("$logs/*.log")) {
        if($file =~ /\/(\d+-\d+-\d+)-(\S+)-(\S+)\.log$/) {
            # A volume's logfile
            my ($day, $host, $volume) = ($1, $2, $3);
            # Find the last line
            open(F,"<$file") or die "ERROR: $file: $!\n";
            my $result = "UNKNOWN";
            while(defined($_ = <F>)) {
                $result = $_;
            }
            close F;
            chomp $result;
            $results{$host}->{$volume}->{$day} = $result;
            # We'll display the logfile if there's a problem
            if($result ne 'OK') {
                $logfiles{$host}->{$volume}->{$day} = $file;
            }
        }
    }
    my @html = ();
    push(@html, "<html>\n");
    push(@html, "  <head>\n");
    push(@html, "    <title>Backup Report ($today)</title>\n");
    push(@html, "    <style type=\"text/css\">\n");
    push(@html, $css);
    push(@html, "    </style>\n");
    push(@html, "  </head>\n");
    push(@html, "  <body>\n");
    push(@html, "    <h1>Backup Report for $today</h1>\n");
    push(@html, "    <h2>Summary</h2>\n");
    push(@html, "    <table>\n");
    push(@html, "      <tr>\n");
    push(@html, "        <th>Host\n");
    push(@html, "        <th>Volume\n");
    push(@html, "        <th>Oldest\n");
    push(@html, "        <th>Newest\n");
    push(@html, "        <th>Total\n");
    #push(@html, "        <th>Space\n");
    for my $host (sort keys %hosts) {
        my $hostdata = $hosts{$host};
        my @volumes = sort keys %{$hostdata->{volumes}};
        my $nvolumes = scalar @volumes;
        push(@html, "      <tr>\n");
        push(@html, "        <td class=host rowspan=$nvolumes>$host\n");
        my $first = 1;
        for my $volume (@volumes) {
            my $volumedata = $hostdata->{volumes}->{$volume};
            my @backups;
            if(exists $results{$host}
               and exists $results{$host}->{$volume}) {
                @backups = sort keys %{$results{$host}->{$volume}};
            } else {
                @backups = ();
            }
            my ($oldest, $newest);
            my $count = 0;
            #my $space = 0;
            for my $date (@backups) {
                # Tot up space used even for incomplete backups
                #my $kbytes = `du -ks \Q$backup\E`;
                #if($?) {
                #    ++$errors;
                #}
                #$kbytes =~ s/^\s*(\d+).*/$1/;
                #$space += $kbytes;
                # Only include successful backups
                if($results{$host}->{$volume}->{$date} eq 'OK') {
                    $oldest = $date if !defined $oldest or $date lt $oldest;
                    $newest = $date if !defined $newest or $date gt $oldest;
                    ++$count;
                }
            }
            push(@html, "      <tr>\n") unless $first;
            if(exists $logfiles{$host}
               and exists $logfiles{$host}->{$volume}) {
                push(@html, "        <td class=volume><a href=\"#$volume\">$volume</a>\n");
            } else {
                push(@html, "        <td class=volume>$volume\n");
            }
            if($count > 0) {
                push(@html, "        <td>$oldest\n");
                if(day_number($today) - day_number($newest) <= $maxage) {
                    push(@html, "        <td class=good>$newest\n");
                } else {
                    push(@html, "        <td class=bad>$newest\n");
                }
                if($count >= $volumedata->{minbackups}) {
                    push(@html, "        <td class=good>$count\n");
                } else {
                    push(@html, "        <td class=bad>$count\n");
                }
            } else {
                push(@html, "        <td class=bad>????-??-??\n");
                push(@html, "        <td class=bad>????-??-??\n");
                push(@html, "        <td class=bad>?\n");
            }
            #if($space <= 4096) {
            #    push(@html, "        <td>",$space, "Kb\n");
            #} elsif($space <= 1024 * 4096) {
            #    push(@html, "        <td>", int($space/1024), "Mb\n");
            #} elsif($space <= 1048576 * 4096) {
            #    push(@html, "        <td>", int($space/(1024*1024)), "Gb\n");
            #} else {
            #    push(@html, "        <td>", int($space/(1024*1024*1024)), "Tb\n");
            #}
            # TODO highlight just-failed backups
            $first = 0;
        }
    }
    push(@html, "    </table>\n");
    if(keys %logfiles) {
        # Nonempty logfiles
        push(@html, "    <h2>Logfiles</h2>\n");
        for my $host (sort keys %logfiles) {
            my $hostdata = $hosts{$host};
            for my $volume (sort keys %{$logfiles{$host}}) {
                my $volumedata = $hostdata->{volumes}->{$volume};
                my $path = $volumedata->{path};
                push(@html, "    <h3><a name=\"$volume\">$host $volume ($path)</a></h3>\n");
                push(@html, "    <div class=volume>\n");
                for my $day (sort { $b cmp $a } keys %{$logfiles{$host}->{$volume}}) {
                    my $logfile = $logfiles{$host}->{$volume}->{$day};
                    push(@html, "      <h4>$host $volume $day</h3>\n");
                    push(@html, "      <pre class=log>");
                    open(L, "<$logfile") or die "ERROR: $logfile: $!\n";
                    while(defined($_ = <L>)) {
                        s/[\&<]/sprintf("&#%d;", ord(chr($1)))/ge;
                        push(@html, $_);
                    }
                    close L;
                    push(@html, "</pre>\n");
                }
                push(@html, "    </div>\n");
            }
        }
    }
    push(@html, "    <p>Generated ", (scalar localtime), ".\n");
    # TODO include tz
    (open(HTML, ">$html")
     and (print HTML @html)
     and (close HTML))
        or die "ERROR: creating $html: $!\n";
}

print STDERR "$errors errors detected.\n" if $errors;
exit !!$errors;

=head1 RESTORING

Restore costs extra l-)

=head2 Manual Restore

The backup has the same layout, permissions etc as the original
system, so it's perfectly possible to simply copy files from a backup
directory to their proper location.

Be careful to get file ownership right.  The backup is stored with the
same I<numeric> user and group ID as the original system used.

=head2 Restoring With rsync

S<rsync -aSHz --numeric-ids /store/chymax/2010-04-01/users/rjk/. chymax:~rjk/.>

You could add the B<--delete> option if you wanted to restore to
exactly the status quo ante, or at the opposite extreme B<--existing>
if you only wanted to restore files that had been deleted.

You might prefer to rsync back into a staging area and then pick files
out manually.

=head2 Restoring with tar

You could tar up a backup directory (or a subset of it) and then untar
it on the target.  Remember to use the B<--numeric-owner> option to
tar.

=head1 MANAGING BACKUPS

The backup management tools are the HTML report; the "comfort"
settings; and the prune settings.

=head2 Report Contents

The HTML report contains the following information for each volume:

=over

=item

The date of the oldest and most recent complete backup.  If the most
recent backup is older than the B<max-age> setting for the volume, it
is highlighted in red.

=item

The number of complete backups.  If this is smaller than the
B<min-backups> setting for the volume, is is highlighted in red.

=item

Any nonempty logfiles.

=back

You should review the report regularly, and take action if there are
any red cells.

=head2 Comfort Settings

For a volume that is supposed to be always available and backed up
daily, set B<max-age> to 0.  If it misses even one backup then it will
be marked in red in the report.

If you back up the volume less often then set a higher B<max-age>
accordingly.  For instance, a desktop system might be left on
overnight for backups just once a week.  In that case B<max-age>
would be set to 6.

If you only care about the most recent backup of a volume then set
B<min-backups> and B<prune-age> to 1.  Only the most recent complete
backup will be kept.

If you want to be able to retrieve snapshots of old versions of a
volume, set B<prune-age> to the maximum distance back in time you want
to go.

=head2 Pruning

The B<--prune> option can be used to automatically delete old backups.
Any backup older than the B<prune-age> setting for the volume will be
delete (whether it is complete or not), with the exception that the
number of backups for the volume will never be reduced below its
B<min-backups> setting.

B<--prune-incomplete> can be used to delete I<incomplete> backups.  It
will still delete them even if they are less than B<prune-age> days
old.  It's suggested that this is only used manually if the number of
incomplete backups is getting out of hand.

=head1 FILES

=over

=item I</etc/rsbackup.conf>

Configuration file.

=item I<LOGS/YYYY-MM-DD-HOST-VOLUME.log>

Log file for one attempt to back up a volume.

=item I<LOGS/prune.log>

Log of recently pruning actions.

=item I<STORE/HOST/YYYY-MM-DD/VOLUME>

One backup for a volume.

=item I<STORE/HOST/YYYY-MM-DD/VOLUME.incomplete>

Exists while backup isn't (yet) complete.

=back

=head1 BUGS

B<--numeric-ids> is mandatory, and should be optional.

There is no support for concurrently backing up from multiple hosts.
Workaround: run a separate copy for each host.

The pruning log is not reflected in the report, and not itself pruned
or rotated.

There should be a B<--version> option.

The report should highlight when the most recent backup of a volume
failed.

There should be an option to email the report somewhere.

There should be a plain text version of the report.

It should be possible to take disk space into account when pruning.

The command line selection syntax should support deselection.

rsbackup should be aware of the use of multiple stores.

Space used on backup volumes should be included in the report.

=head1 AUTHOR

Richard Kettlewell <rjk@greenend.org.uk>

=cut
