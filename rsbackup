#! /usr/bin/perl -w
#
# Copyright Â© 2010 Richard Kettlewell
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
#
use strict;
use POSIX;
use IO::File;
use Time::Local;

=head1 NAME

rsbackup - rsync-based backup utility

=head1 SYNOPSIS

B<rsbackup> [OPTIONS] [HOST...]

=head1 DESCRIPTION

Backs up files from one or more (remote) destinations to a single
backup storage directory, preserving their layout, permissions,
timestamps and hardlink structure.

=cut

our $store;                     # where to store backups
our $config = "/etc/rsbackup.conf"; # config file
our %hosts = ();                # per-host configuration
our $verbose = 0;               # verbose mode
our $act = 1;                   # act (i.e. opposite of --dry-run)
our $private = 1;               # backups are private
our $test;                      # test before backing up
our $html;                      # HTML output
our $backup = 0;                # make a backup
our $errors = 0;                # number of errors
our $logs = "/var/log/backup";  # log directory
our $minbackups = 3;            # minimum backups to be comfortable
our $maxage = 3;                # maximum age to be comfortable
our $css = "body {
  color: black;
  background-color: white
}

a:link, a:visited, a:active {
  color: black;
  text-decoration: none
}

h1 {
  background-color: #e0ffe0
}

table {
  border-collapse: collapse
}

th {
  background-color: #e0e0e0;
  border-left: 1px solid #e0e0e0;
  border-top: 1px solid #e0e0e0;
  border-right: 1px solid #e0e0e0
}

td {
  border: 1px solid black;
  vertical-align: top;
  padding-left: 4px;
  padding-right: 4px
}

td.bad {
  background-color: #ff0000;
  color: #ffffff
}
";

sub make_dir($) {
    my $dir = shift;
    if(!-d $dir) {
        print STDERR "mkdir $dir\n" if $verbose;
        if($act) {
            mkdir($dir) or die "ERROR: mkdir $dir: $!\n";
        }
    }
}

sub split_line($) {
    local $_ = shift;
    my @s = ();
    while(!/^$/) {
        if(/^\s+(.*)/) {
            $_ = $1;
            next;
        }
        if(/^([^\"\\\s]+)(.*)/) {
            push(@s, $1);
            $_ = $2;
            next;
        }
        if(/^\"((?:[^\"\\]|\\[\"\\])+)\"(.*)/) {
            my $quoted = $1;
            $_ = $2;
            $quoted =~ s/\\(.)/$1/g;
            push(@s, $quoted);
            next;
        }
        die "syntax error\n";
    }
    return @s;
}

# Convert YYYY-MM-DD into a day number
sub day_number {
    my ($y, $m, $d);
    if(scalar @_ == 3) {
        ($y, $m, $d) = @_;
    } else {
        ($y, $m, $d) = split(/-/, $_[0]);
    }
    my $t = timegm(0, 0, 0, $d, $m - 1, $y - 1900);
    return $t / 86400;
}

=head1 OPTIONS

=over

=item B<--config> PATH

The path to the configuration file.  The default is
I</etc/rsbackup.conf>.

=item B<--store> PATH

The path to the directory to store backups.  This option overrides the
setting in the configuration file.

=item B<--verbose>

Enable verbose mode.  Various messages will be displayed to report
progress and the rsync B<--quiet> option is suppressed.

=item B<--dry-run>

Enable dry-run mode.  Commands will be displayed but nothing will
actually be done.

=item B<--html> PATH

Write an HTML report.

=item B<--backup>

Make a backup.

If hostnames are specified on the command line then only those hosts
are backed up.  Otherwise all hosts in the config file are backed up.

=item B<--help>

Display a usage message.

=back

=cut

# Parse command-line options
while(@ARGV > 0 && $ARGV[0] =~ /^-/) {
    local $_ = shift;

    if($_ eq "--store") {
        $store = shift;
    } elsif($_ eq "--config") {
        $config = shift;
    } elsif($_ eq "--verbose") {
        $verbose = 1;
    } elsif($_ eq "--html") {
        $html = shift;
    } elsif($_ eq "--backup") {
        $backup = 1;
    } elsif($_ eq "--dry-run") {
        $act = 0;
        $verbose = 1;
    } elsif($_ eq "--") {
        last;
    } elsif($_ eq "--help") {
        print <<EOF;
Usage:
  rsbackup [OPTIONS] [HOST...]

Options:
  --store DIR         Override directory to store backups in
  --config PATH       Set config file (/etc/rsbackup.conf)
  --dry-run           Dry run only
  --verbose           Verbose output
  --backup            Make a backup
  --html PATH         Write an HTML report
  --help              Display usage message

If no hosts are specified then all hosts in the config file are backed up.
Otherwise the named hosts are backed up.
EOF
    } else {
        die "ERROR: unknown option: '$_'\n";
    }
}

if(!$backup and !defined $html) {
    die "ERROR: no action specified\n";
}

=head1 CONFIG FILE

The config file contains global directives and a series of host
stanzas.  Each host stanze in turn contains host directives and volume
stanzas.  Although it is not enforced it is suggested that host and
volume stanzas are indented.

Comments are introduced by an initial "#".

Command arguments may be quoted, using "double quotes".  Quotes and
backslashes within quoted strings are escaped with backslashes.

=head2 Global Directives

=over

=item B<store> PATH

The path to the directory to store backups.  This directive may be
overriden on the command line.

=item B<public>

The store is public.  Normally the store must only be accessible by
the calling user.  This option suppresses the check.

=item B<test> COMMAND

The shell command to test whether to proceed.  If the command fails
(exits nonzero) then the backup will be aborted.

For instance this could be used to test for the presence of a
particular file, to avoid the backup being taken if the backup device
is not mounted.

=item B<logs> PATH

The directory to store logfiles.  The default is I</var/log/backup>.

=item B<max-age> DAYS

The maximum age of the most recent backup before you feel
uncomfortable.

=item B<min-backups> COUNT

The minimum number of backups you feel comfortable with.

=back

=head2 Host Directives

A host stanza is started by a B<host> directive.  It contains other
host directives, and one or more volume stanzas.

=over

=item B<host> HOST

Introduce a host stanza.  The name is used for the backup directory
for this host.

=item B<hostname> HOSTNAME

The SSH hostname for this host.  The default is the name from the host
stanza.

The hostname "localhost" is treated specially: it is assumed to always
be identical to the local system, so files will be read from the local
filesystem.

=item B<user> USERNAME

The SSH username for this host.  The default is not to supply a
username.

=back

In addition, B<min-backups> and B<max-age> can be used within a host
stanza, and apply to just that host.

=head2 Volume Directives

A volume stanza is started by a B<volume> directive.  It contains one
or more volume directives.

=over

=item B<volume> VOLUME PATH

Introduce a volume stanza.  The name is used for the backup directory
for this volume.  The path is the absolute path on the host.

=item B<exclude> PATTERN

An exclusion for this volume.  The pattern is passed to the rsync
B<--exclude> option.  This directive may appear multiple times per
volume.

See the rsync man page for full details.

=item B<traverse>

Traverse mount points.  This suppresses the rsync B<--one-file-system>
option.

=back

In addition, B<min-backups> and B<max-age> can be used within a volume
stanza, and apply to just that volume.

=cut

# Read config file
open(CONFIG, "<$config") or die "$config: $!\n";
my $host;
my $volume;
my $line = 0;
while(defined($_ = <CONFIG>)) {
    ++$line;
    chomp;
    next if /^#/;
    my @s;
    eval {
        @s = split_line($_);
    };
    die "$config:$line: $@" if $@;
    next if !@s;
    my $cmd = shift @s;
    if($cmd eq 'host') {
        $host = $s[0];
        die "$config:$line: invalid hostname '$host'\n" 
            unless $host =~ /^[a-z0-9\-\.]+$/i;
        $hosts{$host} = {
            "volumes" => {},
            "minbackups" => $minbackups,
            "maxage" => $maxage,
        } unless exists $hosts{$host};
    } elsif($cmd eq 'user') {
        die "$config:$line: user command with no preceding host command\n"
            unless defined $host;
        my $user = $s[0];
        $hosts{$host}->{"user"} = $user;
    } elsif($cmd eq 'hostname') {
        die "$config:$line: hostname command with no preceding host command\n"
            unless defined $host;
        my $hostname = $s[0];
        $hosts{$host}->{"hostname"} = $hostname;
    } elsif($cmd eq 'volume') {
        die "$config:$line: volume command with no preceding host command\n"
            unless defined $host;
        $volume = $s[0];
        die "$config:$line: invalid volume name '$volume'\n" 
            unless $volume =~ /^[a-z0-9\-\.]+$/i;
        my $path = $s[1];
        $hosts{$host}->{volumes}->{$volume} =
            {
                "path" => $path,
                "exclude" => [],
                "minbackups" => $hosts{$host}->{minbackups},
                "maxage" => $hosts{$host}->{maxage},
            };
    } elsif($cmd eq 'exclude') {
        die "$config:$line: store command with no preceding volume command\n"
            unless defined $volume;
        push(@{$hosts{$host}->{volumes}->{$volume}->{exclude}}, $s[0]);
    } elsif($cmd eq 'traverse') {
        die "$config:$line: traverse command with no preceding volume command\n"
            unless defined $volume;
        $hosts{$host}->{volumes}->{$volume}->{traverse} = 1;
    } elsif($cmd eq 'store') {
        $store = $s[0] unless defined $store;
    } elsif($cmd eq 'logs') {
        $logs = $s[0];
    } elsif($cmd eq 'public') {
        $private = 0;
    } elsif($cmd eq 'min-backups') {
        if(defined $volume) {
            $hosts{$host}->{volumes}->{$volume}->{minbackups} = $s[0];
        } elsif(defined $host) {
            $hosts{$host}->{minbackups} = $s[0];
        } else {
            $minbackups = $s[0];
        }
    } elsif($cmd eq 'max-age') {
        if(defined $volume) {
            $hosts{$host}->{volumes}->{$volume}->{maxage} = $s[0];
        } elsif(defined $host) {
            $hosts{$host}->{maxage} = $s[0];
        } else {
            $maxage = $s[0];
        }
    } elsif($cmd eq 'test') {
        $test = $s[0];
    } else {
        die "$config:$line: unknown config command '$cmd'\n";
    }
}
close CONFIG;

for my $host (keys %hosts) {
    my %volumes = %{$hosts{$host}->{volumes}};
    if(!%volumes) {
        die "ERROR: host $host has no volumes\n";
    }
}

# Override hosts from command line
my @hosts;
if(scalar @ARGV) {
    for my $host (@ARGV) {
        if(!exists $hosts{$host}) {
            die "ERROR: unknown host $host\n";
        }
    }
    @hosts = @ARGV;
} else {
    @hosts = sort keys %hosts;
}

# Backup store had better exist
die "ERROR: $store is not a directory\n" if !-d $store;

# Today's date
my $today = strftime("%Y-%m-%d", localtime);

if($backup) {
    # Make sure log directory exists
    make_dir($logs);

    # Global log
    my $glogfile = "$logs/$today.log";
    my $glog = new IO::File($glogfile, "a");
    $glog or die "ERROR: $glogfile: $!\n";
    $glog->autoflush(1);

    if($private) {
        # Ensure that backup store is owned by us and not readable
        # or writable by anyone else.
        my @s = stat $store;
        if(!-o $store
           || ($s[2] & 077)) {
            system("ls -ld \Q$store\E >&2");
            die "ERROR: unsuitable directory permissions\n";
        }
    }

    if(defined $test) {
        my $rc = system("cd \Q$store\E && $test");
        if($rc) {
            die "ERROR: test failed: '$test'\n";
        }
    }

    # Perform backups
    for my $host (@hosts) {
        print "=== Backing up $host\n" if $verbose;
        make_dir("$store/$host");
        make_dir("$store/$host/$today");
        print STDERR "\n" if $verbose;
        my $hostdata = $hosts{$host};
        for my $volume (keys %{$hostdata->{volumes}}) {
            my $volumedata = $hostdata->{volumes}->{$volume};
            my $path = $volumedata->{path};
            my $storepath = "$store/$host/$today/$volume";
            my $flagpath = "$storepath.incomplete";
            # If the backup directories exists and the flag path does not
            # then we have a complete backup for today already.
            if(-d $storepath and ! -e $flagpath) {
                print STDERR "==== Backup for $host:$volume already complete\n\n"
                    if $verbose;
                next;
            }
            print "==== Backing up $host:$volume $path\n" if $verbose;
            # Create the flag path and then the backup directory.
            if($act) {
                open(O, ">$flagpath") or die "ERROR: creating $flagpath: $!\n";
                close O;
            }
            make_dir("$store/$host/$today/$volume");
            # Base command
            my @cmd = ("rsync",
                       "--archive",
                       "--sparse",
                       "--numeric-ids",
                       "--compress",
                       "--fuzzy",
                       "--hard-links");
            # Options
            push(@cmd, "--quiet") unless $verbose;
            push(@cmd, "--one-file-system") unless $volumedata->{traverse};
            my @exclude = @{$volumedata->{exclude}};
            push(@cmd, map("--exclude=$_", @exclude));
            # Link to old versions if available
            my @old = glob("$store/$host/*/$volume");
            push(@cmd, map("--link-dest=$_/.", @old));
            # Figure out where to rsync from
            my $hostname = $hostdata->{"hostname"} || $host;
            my $source = $hostname;
            $source = "$hostdata->{'/user'}@$hostname" 
                if exists $hostdata->{"user"};
            my $prefix = "$source:";
            $prefix = '' if $source eq 'localhost';
            push(@cmd, "$prefix$volumedata->{path}/.");
            # Where to rsync to
            push(@cmd, "$store/$host/$today/$volume/.");
            print STDERR join(" ", @cmd), "\n" if $verbose;
            # Do the backup
            if($act) {
                my $pid = fork();
                die "ERROR: fork: $!\n" if !defined $pid;
                if($pid == 0) {
                    my $logfile = "$logs/$today-$host-$volume.log";
                    open(STDOUT, ">$logfile") 
                        or die "ERROR: $logfile: $!\n";
                    open(STDERR, ">&STDOUT")
                        or die "ERROR: redirecting stderr: $!\n";
                    exec(@cmd);
                    die "ERROR: executing $cmd[0] failed\n";
                }
                my $w = wait;
                die "ERROR: wait returned wrong PID $w ($!)\n" if $w != $pid;
                if($?) {
                    # On error leave the flag path in place so a
                    # subsequent run knows to retry the backup
                    print STDERR "ERROR: rsync returned status $?\n";
                    ++$errors;
                } else {
                    # On success delete the flag path so a subsequent run
                    # leaves alone.
                    unlink $flagpath;
                }
                $glog->print("$host $volume $?\n") or die "ERROR: $glog: $!\n";
            }
            print STDERR "\n" if $verbose;
        }
    }
}

if(defined $html) {
    my %results = ();
    my $today_number = day_number($today);
    for my $file (glob("$logs/*.log")) {
        if($file =~ /\/(\d+-\d+-\d+)\.log$/) {
            my $day = $1;
            # A day's global logfile
            open(F, "<$file") or die "ERROR: $file: $!\n";
            $results{$day} = {};
            while(defined($_ = <F>)) {
                if(/^(\S+)\s+(\S+)\s+(\d+)$/) {
                    my ($host, $volume, $rc) = ($1, $2, $3);
                    $results{$day}->{$host}->{$volume} = $rc;
                }
            }
            close F;
        }
    }
    my @html = ();
    push(@html, "<html>\n");
    push(@html, "  <head>\n");
    push(@html, "    <title>Backup Report</title>\n");
    push(@html, "    <style type=\"text/css\">\n");
    push(@html, $css);
    push(@html, "    </style>\n");
    push(@html, "  </head>\n");
    push(@html, "  <body>\n");
    push(@html, "    <h1>Backup Report</h1>\n");
    push(@html, "    <table>\n");
    push(@html, "      <tr>\n");
    push(@html, "        <th>Host\n");
    push(@html, "        <th>Volume\n");
    push(@html, "        <th>Oldest\n");
    push(@html, "        <th>Newest\n");
    push(@html, "        <th>Total\n");
    for my $host (sort keys %hosts) {
        my $hostdata = $hosts{$host};
        my @volumes = sort keys %{$hostdata->{volumes}};
        my $nvolumes = scalar @volumes;
        push(@html, "      <tr>\n");
        push(@html, "        <td class=host rowspan=$nvolumes>$host\n");
        my $first = 1;
        for my $volume (@volumes) {
            my $volumedata = $hostdata->{volumes}->{$volume};
            my @backups = glob("$store/$host/*/$volume");
            my ($oldest, $newest);
            my $count = 0;
            for my $backup (@backups) {
                # Skip incomplete backups
                next if -e "$backup.incomplete";
                my @bits = split(/\//, $backup);
                my $date = $bits[$#bits - 1];
                $oldest = $date if !defined $oldest or $date lt $oldest;
                $newest = $date if !defined $newest or $date gt $oldest;
                ++$count;
            }
            push(@html, "      <tr>\n") unless $first;
            push(@html, "        <td class=volume>$volume\n");
            push(@html, "        <td>$oldest\n");
            if(day_number($today) - day_number($oldest) <= $maxage) {
                push(@html, "        <td class=good>$newest\n");
            } else {
                push(@html, "        <td class=bad>$newest\n");
            }
            if($count >= $volumedata->{minbackups}) {
                push(@html, "        <td class=good>$count\n");
            } else {
                push(@html, "        <td class=bad>$count\n");
            }
            # TODO colorize out-of-spec values
            # TODO highlight just-failed backups; expose error report from rsync
            # TODO include size?
            $first = 0;
        }
    }
    push(@html, "    </table>\n");
    push(@html, "    <p>Generated ", (scalar localtime), ".\n");
    # TODO include tz
    (open(HTML, ">$html")
     and (print HTML @html)
     and (close HTML))
        or die "ERROR: creating $html: $!\n";
}

print STDERR "$errors errors detected.\n" if $errors;
exit !!$errors;

=head1 RESTORING

Restore costs extra l-)

=head2 Manual Restore

The backup has the same layout, permissions etc as the original
system, so it's perfectly possible to simply copy files from a backup
directory to their proper location.

Be careful to get file ownership right.  The backup is stored with the
same I<numeric> user and group ID as the original system used.

=head2 Restoring With rsync

S<rsync -aSHz --numeric-ids /store/chymax/2010-04-01/users/rjk/. chymax:~rjk/.>

You could add the B<--delete> option if you wanted to restore to
exactly the status quo ante, or at the opposite extreme B<--existing>
if you only wanted to restore files that had been deleted.

You might prefer to rsync back into a staging area and then pick files
out manually.

=head2 Restoring with tar

You could tar up a backup directory (or a subset of it) and then untar
it on the target.  Remember to use the B<--numeric-owner> option to
tar.

=head1 BUGS

B<--numeric-ids> is mandatory, and should be optional.

There is no support for concurrently backing up from multiple hosts.
Workaround: run a separate copy for each host.

=head1 AUTHOR

Richard Kettlewell <rjk@greenend.org.uk>

=cut
