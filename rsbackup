#! /usr/bin/perl -w
#
# Copyright Â© 2010 Richard Kettlewell
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
#
use strict;
use POSIX;
use IO::File;
use IO::Dir;
use Time::Local;
use Data::Dumper;
use Fcntl qw(:flock);

=head1 NAME

rsbackup - rsync-based backup utility

=head1 SYNOPSIS

B<rsbackup> [OPTIONS] [--] [SELECTOR...]

=head1 DESCRIPTION

Backs up files from one or more (remote) destinations to a single
backup storage directory, preserving their contents, layout,
ownership, permissions, timestamps and hardlink structure.

=cut

sub parse_config($);

# Settings ---------------------------------------------------------------------

our $version = "0.0";           # version number

our @stores = ();               # known stores
our $store;                     # where to store backups
our %devices = ();              # list of know device names
our $config = "/etc/rsbackup/config"; # config file
our %hosts = ();                # per-host configuration
our $verbose = 0;               # verbose mode
our $debug = 0;
our $act = 1;                   # act (i.e. opposite of --dry-run)
our $private = 1;               # backups are private
our $html;                      # HTML output
our $email;                     # Email report
our $sendmail = "/usr/sbin/sendmail"; # MTA
our $backup = 0;                # make a backup
our $prune = 0;                 # prune old backups
our $prune_incomplete = 0;      # prune incompete backups
our $prune_unknown = 0;         # prune backups on unknown devices
our $errors = 0;                # number of errors
our $logs = "/var/log/backup";  # log directory
our $maxage = 3;                # maximum age to be comfortable
our $pruneage = 366;            # age at which backups may be pruned
our $sshtimeout = 3;            # SSH timeout to check host is up
our $keepprunelog = 31;         # how long to keep prune log for
our $lockfile;                  # path to backup lockfile
my $today = strftime("%Y-%m-%d", localtime); # today's date

# Stylesheet for HTML output
our $css = "body {
  color: black;
  background-color: white
}

a:link, a:visited, a:active {
  color: blue;
  text-decoration: underline
}

h1 {
  background-color: #e0ffe0
}

h2 {
  background-color: #e0e0e0
}

h3 {
  text-decoration: underline
}

h1,h2,h3,h4 {
  font-family: sans-serif
}

table {
  border-collapse: collapse
}

th {
  background-color: #e0e0e0;
  border-left: 1px solid #e0e0e0;
  border-top: 1px solid #e0e0e0;
  border-right: 1px solid #e0e0e0
}

td {
  border: 1px solid black;
  vertical-align: top;
  padding-left: 4px;
  padding-right: 4px
}

td.bad {
  background-color: #e00000;
  color: #ffffff
}

td.good {
  background-color: #e0ffe0;
  color: #000000
}

pre.log {
  background-color: #f0f0f0
}

div.volume {
  margin-left: 1em
}
";

# Utilities --------------------------------------------------------------------

# make_dir($PATH)
#
# Creates directory PATH if it does not already exists.  Honors --dry-run
# and --verbose.  dies on error.
sub make_dir($) {
    my $dir = shift;
    if(!-d $dir) {
        print "mkdir $dir\n" if $verbose;
        if($act) {
            mkdir($dir) or die "ERROR: mkdir $dir: $!\n";
        }
    }
}

# @BITS = split_line($LINE)
#
# Split a line into its components.  Components can be delimited either by
# "quotes" or by whitespace.  dies on error; the caller is expected to
# catch the error and add line number information etc.
sub split_line($) {
    local $_ = shift;
    my @s = ();
    while(!/^$/) {
        if(/^\s+(.*)/) {
            $_ = $1;
            next;
        }
        if(/^([^\"\\\s]+)(.*)/) {
            push(@s, $1);
            $_ = $2;
            next;
        }
        if(/^\"((?:[^\"\\]|\\[\"\\])+)\"(.*)/) {
            my $quoted = $1;
            $_ = $2;
            $quoted =~ s/\\(.)/$1/g;
            push(@s, $quoted);
            next;
        }
        die "syntax error\n";
    }
    return @s;
}

# $DAY = day_number($YEAR, $MONTH, $DAY)
#
# Converts a date into a (UNIX-epoch) day number.  Years are CE years,
# months start at 1 for January and days at 1 for the first of the
# month.
sub day_number {
    my ($y, $m, $d);
    if(scalar @_ == 3) {
        ($y, $m, $d) = @_;
    } else {
        ($y, $m, $d) = split(/-/, $_[0]);
    }
    my $t = timegm(0, 0, 0, $d, $m - 1, $y - 1900);
    return $t / 86400;
}

# Parse command-line options ---------------------------------------------------

=head1 OPTIONS

=head2 Action Options

At least one of these options must be specified.  When multiple
actions are specified, they are executed in the order shown below.

=over

=item B<--backup>

Make a backup of the selected volumes.

=item B<--prune>

Prune old backups of selected volumes.

=item B<--prune-incomplete>

Prune incomplete backups of selected volumes.

=item B<--prune-unknown>

Prune logs of backups that are on unknown devices.

=item B<--html> PATH

Write an HTML report.  The report covers all volumes, not just
selected ones.

=item B<--email> ADDRESS

Email an HTML report.

=back

=head2 General Options

=over

=item B<--config> PATH

The path to the configuration file.  The default is
I</etc/rsbackup/config>.

=item B<--store> PATH

The path to the directory to store backups.  This option overrides the
B<store> directive in the configuration file.

=item B<--verbose>

Enable verbose mode.  Various messages will be displayed to report
progress and the rsync B<--quiet> option is suppressed.

=item B<--dry-run>

Enable dry-run mode.  Commands will be displayed but nothing will
actually be done.

This affects the B<--backup>, B<--prune> and B<--prune-incomplete>
options.

=item B<--help>

Display a usage message.

=item B<--version>

Display the version number.

=back

=head2 Volume Selection

The list of selectors on the command line determines what subset of
the known volumes are backed up (or pruned).  The following selectors
are possible:

=over 16

=item HOST

Select all volumes for the host.

=item HOSTB<:>VOLUME

Select the volume.

=item B<->HOST

Deselect all volumes for the host.

=item B<->HOSTB<:>VOLUME

Deselect the volume.

=item B<*>

Select all volumes.

=back

If no hosts or volumes are specified on the command line then all
volumes are selected.

=cut

while(@ARGV > 0 && $ARGV[0] =~ /^--/) {
    local $_ = shift;

    if($_ eq "--store") {
        $store = shift;
        die "ERROR: missing argument to --store\n" unless defined $store;
    } elsif($_ eq "--config") {
        $config = shift;
        die "ERROR: missing argument to --config\n" unless defined $config;
    } elsif($_ eq "--verbose") {
        $verbose = 1;
    } elsif($_ eq "--debug") {
        $debug = 1;
    } elsif($_ eq "--html") {
        $html = shift;
        die "ERROR: missing argument to --html\n" unless defined $html;
    } elsif($_ eq "--email") {
        $email = shift;
        die "ERROR: missing argument to --email\n" unless defined $email;
    } elsif($_ eq "--backup") {
        $backup = 1;
    } elsif($_ eq "--prune") {
        $prune = 1;
    } elsif($_ eq "--prune-incomplete") {
        $prune_incomplete = 1;
    } elsif($_ eq "--prune-unknown") {
        $prune_unknown = 1;
    } elsif($_ eq "--dry-run") {
        $act = 0;
        $verbose = 1;
    } elsif($_ eq "--") {
        last;
    } elsif($_ eq "--help") {
        print <<EOF;
Usage:
  rsbackup [OPTIONS] [--] [[-]HOST...] [[-]HOST:VOLUME...]

At least one action option is required:
  --backup            Make a backup
  --html PATH         Write an HTML report
  --prune             Prune old backups
  --prune-incomplete  Prune incomplete backups
  --prune-unknown     Prune logs for lost devices

Additional options:
  --store DIR         Override directory to store backups in
  --config PATH       Set config file (/etc/rsbackup/config)
  --dry-run           Dry run only
  --verbose           Verbose output
  --help              Display usage message
  --version           Display version number

If no volumes are specified then all volumes in the config file are backed up.
Otherwise the specified volumes are backed up.
EOF
        exit 0;
    } elsif($_ eq "--version") {
        print "$version\n";
        exit 0;
    } else {
        die "ERROR: unknown option: '$_'\n";
    }
}

# Have to do _something_
if(!$backup
   and !defined $html
   and !defined $email
   and !$prune
   and !$prune_incomplete) {
    die "ERROR: no action specified\n";
}

# Parse config file ------------------------------------------------------------

=head1 CONFIG FILE

The config file contains global directives and a series of host
stanzas.  Each host stanze in turn contains host directives and volume
stanzas.  Although it is not enforced it is suggested that host and
volume stanzas are indented.

Comments are introduced by an initial "#".

Command arguments may be quoted, using "double quotes".  Quotes and
backslashes within quoted strings are escaped with backslashes.

=head2 Global Directives

=over

=item B<store> PATH

A path at which a backup device may be mounted.  This can be used
multiple times.

=item B<device> DEVICE

Names a device.  This can be used multiple times.  The store must have
a file called I<STORE/device-id> which contains a known device name.
Backups will only be made to known devices.

When a device is lost or destroyed, remove its B<device> entry and use
the B<--prune-unknown> option to delete logs of backups on it.

Device names may contain letters, digits, dots and underscores.

=item B<public>

The store is public.  Normally the store must only be accessible by
the calling user.  This option suppresses the check.

=item B<logs> PATH

The directory to store logfiles.  The default is I</var/log/backup>.

=item B<lock> PATH

Enable locking.  If this directive is present then PATH will be used
as a lockfile for operations that change anything (B<--backup>,
B<--prune>, B<--prune-incomplete> and B<--prune-unknown>).

=item B<ssh-timeout> SECONDS

How long to wait before concluding a host is down.  The default is 3.

=item B<max-age> DAYS

The maximum age of the most recent backup before you feel
uncomfortable.  The default is 3, meaning that if a volume hasn't been
backed up in the last 3 days it will have red ink in the HTML report.

=item B<prune-age> DAYS

The age at which a backup may be pruned.  The default is 366, meaning
a backup will never be pruned until it is at least a whole year old.

=item B<keep-prune-logs> DAYS

The number of days to keep prune logs for.  The default is 31.

=item B<include> PATH

Include another file as part of the configuration.  If I<PATH> is a
directory then the files within it are included (excluding dotfiles
and backup files).

=back

=head2 Host Directives

A host stanza is started by a B<host> directive.  It contains other
host directives, and one or more volume stanzas.

=over

=item B<host> HOST

Introduce a host stanza.  The name is used for the backup directory
for this host.

=item B<hostname> HOSTNAME

The SSH hostname for this host.  The default is the name from the host
stanza.

The hostname "localhost" is treated specially: it is assumed to always
be identical to the local system, so files will be read from the local
filesystem.

=item B<user> USERNAME

The SSH username for this host.  The default is not to supply a
username.

=back

In addition, B<prune-age> and B<max-age> can be used within a host
stanza, and apply to just that host.

=head2 Volume Directives

A volume stanza is started by a B<volume> directive.  It contains one
or more volume directives.

=over

=item B<volume> VOLUME PATH

Introduce a volume stanza.  The name is used for the backup directory
for this volume.  The path is the absolute path on the host.

=item B<exclude> PATTERN

An exclusion for this volume.  The pattern is passed to the rsync
B<--exclude> option.  This directive may appear multiple times per
volume.

See the rsync man page for full details.

=item B<traverse>

Traverse mount points.  This suppresses the rsync B<--one-file-system>
option.

=back

In addition, B<prune-age> and B<max-age> can be used within a volume
stanza, and apply to just that volume.

=cut

sub parse_config($) {
    my $path = shift;
    my $input = new IO::File($path, O_RDONLY);
    die "ERROR: $path: $!\n" unless defined $input;
    my $host;
    my $volume;
    my $line = 0;
    while(defined($_ = $input->getline())) {
        ++$line;
        chomp;
        next if /^#/;
        my @s;
        eval {
            @s = split_line($_);
        };
        die "$path:$line: $@" if $@;
        next if !@s;
        my $cmd = shift @s;
        if($cmd eq 'host') {
            $host = $s[0];
            die "$path:$line: invalid hostname '$host'\n" 
                unless $host =~ /^[a-z0-9\-\.]+$/i;
            die "$path:$line: duplicate hostname '$host'\n"
                if exists $hosts{$host};
            $hosts{$host} = {
                "volumes" => {},
                "maxage" => $maxage,
                "pruneage" => $pruneage,
                "selected" => 0,
            } unless exists $hosts{$host};
            undef $volume;
        } elsif($cmd eq 'user') {
            die "$path:$line: user command with no preceding host command\n"
                unless defined $host;
            my $user = $s[0];
            $hosts{$host}->{"user"} = $user;
        } elsif($cmd eq 'hostname') {
            die "$path:$line: hostname command with no preceding host command\n"
                unless defined $host;
            my $hostname = $s[0];
            $hosts{$host}->{"hostname"} = $hostname;
        } elsif($cmd eq 'volume') {
            die "$path:$line: volume command with no preceding host command\n"
                unless defined $host;
            $volume = $s[0];
            die "$path:$line: invalid volume name '$volume'\n"
                unless $volume =~ /^[a-z0-9\-\.]+$/i;
            die "$path:$line: duplicate volume name '$volume'\n"
                if exists $hosts{$host}->{volumes}->{$volume};
            my $path = $s[1];
            $hosts{$host}->{volumes}->{$volume} =
            {
                "path" => $path,
                "exclude" => [],
                "maxage" => $hosts{$host}->{maxage},
                "pruneage" => $hosts{$host}->{pruneage},
                "selected" => 0,
            };
        } elsif($cmd eq 'exclude') {
            die "$path:$line: store command with no preceding volume command\n"
                unless defined $volume;
            push(@{$hosts{$host}->{volumes}->{$volume}->{exclude}}, $s[0]);
        } elsif($cmd eq 'traverse') {
            die "$path:$line: traverse command with no preceding volume command\n"
                unless defined $volume;
            $hosts{$host}->{volumes}->{$volume}->{traverse} = 1;
        } elsif($cmd eq 'store') {
            push(@stores, $s[0]);
        } elsif($cmd eq 'logs') {
            $logs = $s[0];
        } elsif($cmd eq 'ssh-timeout') {
            $sshtimeout = $s[0];
        } elsif($cmd eq 'public') {
            $private = 0;
        } elsif($cmd eq 'keep-prune-logs') {
            $keepprunelog = $s[0];
        } elsif($cmd eq 'prune-age') {
            my $n = int($s[0]);
            die "ERROR: unsuitable prune-age $n\n" if $n <= 0;
            if(defined $volume) {
                $hosts{$host}->{volumes}->{$volume}->{pruneage} = $n;
            } elsif(defined $host) {
                $hosts{$host}->{pruneage} = $n;
            } else {
                $pruneage = $n;
            }
        } elsif($cmd eq 'max-age') {
            my $n = int($s[0]);
            die "ERROR: unsuitable max-age $n\n" if $n <= 0;
            if(defined $volume) {
                $hosts{$host}->{volumes}->{$volume}->{maxage} = $n;
            } elsif(defined $host) {
                $hosts{$host}->{maxage} = $n;
            } else {
                $maxage = $n;
            }
        } elsif($cmd eq 'device') {
            die "ERROR: invalid device name '$s[0]'\n"
                unless $s[0] =~ /^[a-z0-9_\.]+$/i;
            $devices{$s[0]} = 1;
        } elsif($cmd eq 'lock') {
            $lockfile = $s[0];
        } elsif($cmd eq 'include') {
            my $p = shift @s;
            die "$path:$line: missing include path\n" unless defined $p;
            if(-d $p) {
                my $dir = new IO::Dir($p);
                my @files = ();
                my $file;
                while(defined($file = $dir->read())) {
                    next if $file =~ /^\./;
                    next if $file =~ /~/;
                    next unless -f "$p/$file";
                    push(@files, $file);
                }
                for my $file (sort @files) {
                    parse_config("$p/$file");
                }
            } else {
                parse_config($p);
            }
        } else {
            die "$path:$line: unknown config command '$cmd'\n";
        }
    }
    $input->close();
}

parse_config($config);

# Sanity-check configuration ---------------------------------------------------

for my $host (keys %hosts) {
    my %volumes = %{$hosts{$host}->{volumes}};
    if(!%volumes) {
        die "ERROR: host $host has no volumes\n";
    }
}

# Choose what to back up -------------------------------------------------------

# select_host($HOST, $STATE)
#
# Set all of HOST's volumes to STATE (0 for don't back up, 1 for do
# back up).  HOST may be "*" to select all hosts.  dies if HOST does
# not exist.
sub select_host($$) {
    my ($host, $state) = @_;

    if($host eq '*') {
        select_all($state);
    } else {
        if(!exists $hosts{$host}) {
            die "ERROR: host '$host' does not exist\n";
        }
        my $hostdata = $hosts{$host};
        for my $volume (keys %{$hostdata->{volumes}}) {
            select_volume($host, $volume, $state);
        }
    }
}

# select_volume($HOST, $VOLUME, $STATE)
#
# Set HOST:VOLUME's to STATE (0 for don't back up, 1 for do back up).
# dies if HOST or HOST:VOLUME do not exist.
sub select_volume($$$) {
    my ($host, $volume, $state) = @_;

    if(!exists $hosts{$host}) {
        die "ERROR: host '$host' does not exist\n";
    }
    my $hostdata = $hosts{$host};
    if(!exists $hostdata->{volumes}->{$volume}) {
        die "ERROR: volume '$host:$volume' does not exist\n";
    }
    my $volumedata = $hostdata->{volumes}->{$volume};
    $volumedata->{selected} = $state;
}

# select_all($STATE)
#
# Set all volumes of all hosts to STATE (0 for don't back up, 1 for do
# back up).
sub select_all($) {
    my $state = shift;
    for my $host (keys %hosts) {
        select_host($host, $state);
    }
}

# Determine which volumes are selected
if(scalar @ARGV) {
    for my $key (@ARGV) {
        my $state = 1;
        if($key =~ /^[\-!](.*)/) {
            $key = $1;
            $state = 0;
        }
        if($key =~ /(.*):(.*)/) {
            select_volume($1, $2, $state);
        } else {
            select_host($key, $state);
        }
    }
} else {
    select_all(1);
}

# Set each host's selection state to 1 if it has any selected volumes,
# or 0 if it does not.
for my $host (keys %hosts) {
    my $hostdata = $hosts{$host};
    $hostdata->{selected} = 0;
    for my $volume (keys %{$hostdata->{volumes}}) {
        my $volumedata = $hostdata->{volumes}->{$volume};
        if($volumedata->{selected}) {
            $hostdata->{selected} = 1;
            last;
        }
    }
}

print STDERR Data::Dumper->Dump([\%hosts], ["hosts"])
    if $debug;

# Identify valid stores --------------------------------------------------------

# $DEVICE = validate_store($STORE)
#
# Check that STORE corresponds to some device and is safe to use for
# backups (i.e. has suitable permissions etc).  Returns the device
# name.  On error, dies; the caller is expected to catch the erorr.
sub validate_store($) {
    my $store = shift;

    if($private) {
        # Ensure that backup store is owned by us and not readable
        # or writable by anyone else.
        my @s = stat $store;
        if(!-o $store
           || ($s[2] & 077)) {
            die "$store: unsuitable directory permissions\n";
        }
    }

    # Make sure the store is a known device
    open(DEVICE, "<$store/device-id") or die "$store/device-id: $!\n";
    my $device;
    if(!defined($device = <DEVICE>)) {
        die "$store/device-id: no device\n";
    }
    close DEVICE;
    chomp $device;
    if(!exists $devices{$device}) {
        die "$store/device-id: unknown device '$device'\n";
    }
    return $device;
}

# Choose the stores to back up to
our @use_stores = ();           # the list of stores to use
our %store_to_device = ();      # map of store path to device name
our %device_to_store = ();      # map of device name to store path

# choose_stores()
#
# Choose the stores to back up to.  If --store was used then only that
# is used; it is checked for validity.  Otherwise all currently valid
# stores are used.  If there aren't any, terminates the program.
sub choose_stores() {
    if(defined $store) {
        my $device = validate_store($store);
        $store_to_device{$store} = $device;
        $device_to_store{$device} = $store;
        @use_stores = ($store);
    } else {
        my %problem = ();
        for my $s (@stores) {
            my $device;
            eval {
                my $device = validate_store($s);
                $store_to_device{$s} = $device;
                $device_to_store{$device} = $s;
            };
            if($@) {
                $problem{$s} = $@;
            } else {
                push(@use_stores, $s);
            }
        }
        # If we didn't find any suitable stores then report what was wrong
        # with each.
        if(!@use_stores) {
            print STDERR "ERROR: no suitable store found:\n";
            for my $s (@stores) {
                if(exists $problem{$s}) {
                    print STDERR "  $problem{$s}";
                }
            }
            exit 1;
        }
    }
}

if($backup or $prune or $prune_incomplete) {
    choose_stores();
}

# Back up ----------------------------------------------------------------------

# backup_to($STORE)
#
# Backup to a given store.
sub backup_to($) {
    my $store = shift;
    my $device = $store_to_device{$store};
    die "ERROR: cannot map $store to device name\n"
        unless defined $device;

    # Perform backups
    for my $host (sort keys %hosts) {
        my $hostdata = $hosts{$host};
        next unless $hostdata->{selected};
        print "=== Backing up $host\n" if $verbose;
        # Figure out user@host
        my $hostname = $hostdata->{"hostname"} || $host;
        my $userhost = $hostname;
        $userhost = "$hostdata->{'/user'}@$hostname" 
            if exists $hostdata->{"user"};
        my $prefix = "$userhost:";
        $prefix = '' if $userhost eq 'localhost';
        # If the host is not reachable then we won't be able to back
        # it up
        if($prefix ne '') {
            my $rc = system("ssh", "-oConnectTimeout=$sshtimeout", $userhost, "true");
            if($rc != 0) {
                print "$host is not reachable\n\n" if $verbose;
                next;
            }
        }
        make_dir("$store/$host");
        print "\n" if $verbose;
        for my $volume (sort keys %{$hostdata->{volumes}}) {
            my $volumedata = $hostdata->{volumes}->{$volume};
            next unless $volumedata->{selected};
            my $path = $volumedata->{path};
            my $storepath = "$store/$host/$volume/$today";
            my $flagpath = "$storepath.incomplete";
            # If the backup directories exists and the flag path does not
            # then we have a complete backup for today already.
            if(-d $storepath and ! -e $flagpath) {
                print "==== Backup for $host:$volume already complete\n\n"
                    if $verbose;
                next;
            }
            print "==== Backing up $host:$volume $path\n" if $verbose;
            make_dir("$store/$host/$volume");
            make_dir("$store/$host/$volume/$today");
            # Create the flag path and then the backup directory.
            if($act) {
                open(O, ">$flagpath") or die "ERROR: creating $flagpath: $!\n";
                close O;
            }
            # Base command
            my @cmd = ("rsync",
                       "--archive",
                       "--sparse",
                       "--numeric-ids",
                       "--compress",
                       "--fuzzy",
                       "--hard-links");
            # Options
            push(@cmd, "--quiet") unless $verbose;
            push(@cmd, "--one-file-system") unless $volumedata->{traverse};
            my @exclude = @{$volumedata->{exclude}};
            push(@cmd, map("--exclude=$_", @exclude));
            # Link to old versions if available
            my @old = grep(-d $_, glob("$store/$host/$volume/*"));
            push(@cmd, map("--link-dest=$_/.", @old));
            # Figure out where to rsync from
            push(@cmd, "$prefix$volumedata->{path}/.");
            # Where to rsync to
            push(@cmd, "$storepath/.");
            print join(" ", @cmd), "\n" if $verbose;
            # Do the backup
            if($act) {
                my $logfile = "$logs/$today-$device-$host-$volume.log";
                my $pid = fork();
                die "ERROR: fork: $!\n" if !defined $pid;
                if($pid == 0) {
                    open(STDOUT, ">$logfile") 
                        or die "ERROR: $logfile: $!\n";
                    open(STDERR, ">&STDOUT")
                        or die "ERROR: redirecting stderr: $!\n";
                    exec(@cmd);
                    die "ERROR: executing $cmd[0] failed\n";
                }
                my $w = wait;
                die "ERROR: wait returned wrong PID $w ($!)\n" if $w != $pid;
                my $rc = $?;
                # Include status in logfile
                my $msg;
                if($rc) {
                    $msg = sprintf("ERROR: device=%s error=%#x", $device, $rc);
                } else {
                    $msg = sprintf("OK: device=%s", $device);
                }
                (open(LOG, ">>$logfile")
                 and print LOG "$msg\n"
                 and close LOG)
                    or die "ERROR: $logfile: $!\n";
                if($verbose) {
                    # In verbose mode, display the rsync output
                    if(-e $logfile) {
                        system("cat \Q$logfile\E >&2");
                    }
                }
                if($rc) {
                    # On error leave the flag path in place so a
                    # subsequent run knows to retry the backup
                    printf STDERR "ERROR: rsync returned wait status status #%x\n", $rc
                        unless $verbose;
                    ++$errors;
                } else {
                    # On success delete the flag path so a subsequent run
                    # leaves alone.
                    unlink $flagpath;
                }
            }
            print "\n" if $verbose;
        }
    }
}

# Honor lockfile for mutating operations
if($backup or $prune or $prune_incomplete or $prune_unknown) {
    if(defined $lockfile) {
        open(LOCKFILE, ">$lockfile") or die "ERROR: $lockfile: $!\n";
        flock(LOCKFILE, LOCK_EX|LOCK_NB) or die "ERROR: $lockfile: $!\n";
    }
}

if($backup) {
    # Make sure log directory exists
    make_dir($logs);
    for my $s (@use_stores) {
        backup_to($s);
    }
}

# Prepare for logging and pruning ----------------------------------------------

# ($DATE, $DEVICE, $HOST, $VOLUME) = parse_log_name($PATH)
#
# Convert a logfile name.  Returns undef if it does not match the
# logfile name syntax.
sub parse_log_name($) {
    local $_ = shift;
    if(/\/(\d+-\d+-\d+)-([^\-]+)-([^\-]+)-([^\-]+)\.log$/) {
        return ($1, $2, $3, $4);
    } else {
        return undef;
    }
}

my %unknown_devices = ();       # unknown devices we noticed
my @unknown_device_logs = ();   # logfiles for unknown devices

my %results = ();           # result strings for each backup
my %logfiles = ();          # logfiles for failed backups
my $today_number = day_number($today);
if($prune or $prune_incomplete or $prune_unknown or $html or $email) {
    for my $file (glob("$logs/*.log")) {
        my ($date, $device, $host, $volume) = parse_log_name($file);
        next unless defined $date;
        # Record logs for unknown devices
        if(!exists $devices{$device}) {
            push(@unknown_device_logs, $file);
            $unknown_devices{$device} = 1;
            next;
        }
        # Find the last line
        open(F,"<$file") or die "ERROR: $file: $!\n";
        my $result = "UNKNOWN";
        while(defined($_ = <F>)) {
            $result = $_;
        }
        close F;
        chomp $result;
        # Record the result
        $results{$device}->{$host}->{$volume}->{$date} = $result;
        # We'll display the logfile if there's a problem
        $logfiles{$device}->{$host}->{$volume}->{$date} = $file;
    }
}

# Prune logs for unknown devices -----------------------------------------------

if($prune_unknown) {
    print "=== Pruning logs for lost devices\n" if $verbose;
    if(@unknown_device_logs) {
        for my $logfile (@unknown_device_logs) {
            print "Removing $logfile\n" if $verbose;
            if($act) {
                unlink $logfile or die "ERROR: $logfile: $!\n";
            }
        }
        %unknown_devices = ();  # no more unknown devices
    } else {
        print "No unknown devices to prune.\n" if $verbose;
    }
}

# Prune old and incomplete logs ------------------------------------------------

# Logfile for pruning
our $prunelog = "$logs/prune-$today.log";

# prune_backup($LOGFILE, $WHY)
#
# Prune an old backup, identifying it by logfile and giving a reason.
sub prune_backup($$) {
    my ($logfile, $why) = @_;
    my ($date, $device, $host, $volume) = parse_log_name($logfile);
    next unless defined !$date;
    my $s = $device_to_store{$device};
    next unless defined $s;
    my $backup = "$s/$host/$volume/$date";
    for my $f ($backup,
               "$backup.incomplete",
               $logfile) {
        next unless -e $f;
        my @cmd = ("rm", "-rf",  $f);
        print join(" ", @cmd), "\n" if $verbose;
        if($act) {
            my $rc = system(@cmd);
            if($rc) {
                print LOG "$today: Attempted to remove $backup: $why: FAILED\n"
                    or die "ERROR: $prunelog: $!\n";
                die "ERROR: rm failed\n";
            } else {
                print LOG "$today: Removed $backup: $why\n"
                    or die "ERROR: $prunelog: $!\n";
            }
        }
    }
}

# Suppress pruning if there are still logs for unknown devices
if($prune or $prune_incomplete) {
    if(%unknown_devices and $act) {
        print STDERR "WARNING: skipping prune step due to unknown devices\n";
        $prune = 0;
        $prune_incomplete = 0;
    }
}

if($prune or $prune_incomplete) {
    if($act) {
        open(LOG, ">>$prunelog") or die "ERROR: $prunelog: $!\n";
        autoflush LOG 1;
    }
    for my $host (sort keys %hosts) {
        my $hostdata = $hosts{$host};
        next unless $hostdata->{selected};
        print "=== Pruning $host\n" if $verbose;
        for my $volume (sort keys %{$hostdata->{volumes}}) {
            my $volumedata = $hostdata->{volumes}->{$volume};
            next unless $volumedata->{selected};
            my $path = $volumedata->{path};
            my $pruneage = $volumedata->{pruneage};
            print "==== Pruning $host:$volume $path (keep for $pruneage days)\n"
                if $verbose;
            # Prune incomplete backups
            if($prune_incomplete) {
                my @logfiles = sort glob("$logs/*-$host-$volume.log");
                # Identify incomplete backups
                for my $logfile (@logfiles) {
                    my ($date, $device, $host, $volume) = parse_log_name($logfile);
                    next unless defined $date;
                    my $s = $device_to_store{$device};
                    next unless defined $s;
                    my $backup = "$s/$host/$volume/$date";
                    next unless -e "$backup.incomplete";
                    prune_backup($logfile, "incomplete");
                }
            }
            if($prune) {
                # Map of logfile names to deletion reasons
                my %why = ();
                # List of logfiles, sorted by date
                my @logfiles = sort glob("$logs/*-$host-$volume.log");
                # We need at least 1 backup.  Otherwise, no pruning.
                if(scalar @logfiles > 1) {
                    for my $logfile (@logfiles) {
                        my ($date, $device, $host, $volume) = parse_log_name($logfile);
                        next unless defined $date;
                        my $s = $device_to_store{$device};
                        next unless defined $s;
                        my $backup = "$s/$host/$volume/$date";
                        if(day_number($date) < day_number($today) - $pruneage) {
                            prune_backup($logfile, "more than $pruneage days old");
                        }
                    }
                } else {
                    print "Skipping; only 1 backup.\n"
                        if $verbose;
                }
            }
        }
    }
    close LOG if $act;
    if($prune) {
        print "=== Removing old prune logs\n"
            if $verbose;
        # Delete old prune logs
        for my $oldlog (glob("$logs/prune-*.log")) {
            if($oldlog =~ /prune-(\d+-\d+-\d+)\.log$/) {
                my $date = $1;
                my $age = day_number($today) - day_number($date);
                if($age > $keepprunelog) {
                    print "Removing $oldlog ($age days old)\n"
                        if $verbose;
                    if($act) {
                        unlink $oldlog or die "ERROR: removing $oldlog: $!\n";
                    }
                }
            }
        }
    }
}

# Report generation ------------------------------------------------------------

if(defined $html or defined $email) {
    my $title = "Backup Report ($today)";
    my @html = ();
    push(@html, "<html>\n");
    push(@html, "  <head>\n");
    push(@html, "    <title>$title</title>\n");
    push(@html, "    <style type=\"text/css\">\n");
    push(@html, $css);
    push(@html, "    </style>\n");
    push(@html, "  </head>\n");
    push(@html, "  <body>\n");
    push(@html, "    <h1>$title</h1>\n");
    if(%unknown_devices) {
        push(@html, "    <h2>Unknown Devices</h2>\n");
        for my $device (sort keys %unknown_devices) {
            push(@html, "    <p>Device <code class=device>$device</span>:\n");
            push(@html, "    <ul>\n");
            for my $bits (sort @{$unknown_devices{$device}}) {
                push(@html, "      <li>", join(" ", @$bits), "\n");
            }
            push(@html, "    </ul>\n");
        }
    }
    push(@html, "    <h2>Summary</h2>\n");
    push(@html, "    <table>\n");
    push(@html, "      <tr>\n");
    push(@html, "        <th rowspan=3>Host\n");
    push(@html, "        <th rowspan=3>Volume\n");
    push(@html, "        <th rowspan=3>Oldest\n");
    push(@html, "        <th rowspan=3>Total\n");
    push(@html, "        <th colspan=", 2 * keys %devices, ">Devices\n");
    push(@html, "      <tr>\n");
    for my $device (sort keys %devices) {
        push(@html, "        <th colspan=2>$device\n");
    }
    push(@html, "      <tr>\n");
    for my $device (sort keys %devices) {
        push(@html, "        <th>Newest\n");
        push(@html, "        <th>Count\n");
    }
    for my $host (sort keys %hosts) {
        my $hostdata = $hosts{$host};
        my @volumes = sort keys %{$hostdata->{volumes}};
        my $nvolumes = scalar @volumes;
        push(@html, "      <tr>\n");
        push(@html, "        <td class=host rowspan=$nvolumes>$host\n");
        my $first = 1;
        for my $volume (@volumes) {
            my $volumedata = $hostdata->{volumes}->{$volume};
            # Enumerate all known backups for this volume, on all
            # devices; identify the oldest and newst.
            my $oldest;
            my $count = 0;      # backups that succeeded
            my %devcount = ();
            my %devnewest = ();
            for my $device (keys %devices) {
                $devcount{$device} = 0;
                if(exists $results{$device}->{$host}
                   and exists $results{$device}->{$host}->{$volume}) {
                    for my $date (keys %{$results{$device}->{$host}->{$volume}}) {
                        next unless $results{$device}->{$host}->{$volume}->{$date} =~ /OK/;
                        $oldest = $date if !defined $oldest or $date lt $oldest;
                        ++$count;
                        $devnewest{$device} = $date if !exists $devnewest{$device}
                                                     or $date gt $devnewest{$device};
                        ++$devcount{$device};
                    }
                }
            }
            push(@html, "      <tr>\n") unless $first;
            push(@html, "        <td class=volume>$volume\n");
            if($count > 0) {
                # oldest is value-free; we just report it.
                push(@html, "        <td>$oldest\n");
                # the total number of backups is green if every device
                # has a backup of this volume, else red.
                if(grep($devcount{$_} == 0, keys %devices)) {
                    push(@html, "        <td class=bad>$count\n");
                } else {
                    push(@html, "        <td class=good>$count\n");
                }
            } else {
                # no backups of this volume at all, everything's red
                push(@html, "        <td class=bad>????-??-??\n");
                push(@html, "        <td class=bad>?\n");
            }
            for my $device (sort keys %devices) {
                if($devcount{$device}) {
                    # If this volume has a recent enough backup on
                    # this device, the date column is green; if the
                    # newest backup on the device is too old it's red.
                    if(day_number($today) - day_number($devnewest{$device}) <= $maxage) {
                        push(@html, "        <td class=good>$devnewest{$device}\n");
                    } else {
                        push(@html, "        <td class=bad>$devnewest{$device}\n");
                    }
                    # The count for the device is always good if positive.
                    push(@html, "        <td class=good>$devcount{$device}\n");
                } else {
                    push(@html, "        <td class=bad>????-??-??\n");
                    push(@html, "        <td class=bad>$devcount{$device}\n");
                }
            }
            # TODO highlight just-failed backups
            $first = 0;
        }
    }
    push(@html, "    </table>\n");
    push(@html, "    <h2>Logfiles</h2>\n");
    if(keys %logfiles) {
        # Nonempty logfiles
        # TODO ugh, sorting by device first is rather grim.
        for my $device (sort keys %devices) {
            for my $host (sort keys %{$logfiles{$device}}) {
                my $hostdata = $hosts{$host};
                for my $volume (sort keys %{$logfiles{$host}}) {
                    my $volumedata = $hostdata->{volumes}->{$volume};
                    my $path = $volumedata->{path};
                    push(@html, "    <h3>$device $host $volume ($path)</h3>\n");
                    push(@html, "    <div class=volume>\n");
                    for my $day (sort { $b cmp $a } keys %{$logfiles{$device}->{$host}->{$volume}}) {
                        my $logfile = $logfiles{$device}->{$host}->{$volume}->{$day};
                        push(@html, "      <h4>$host $volume $day</h3>\n");
                        push(@html, "      <pre class=log>");
                        open(L, "<$logfile") or die "ERROR: $logfile: $!\n";
                        while(defined($_ = <L>)) {
                            s/[\&<]/sprintf("&#%d;", ord(chr($1)))/ge;
                            push(@html, $_);
                        }
                        close L;
                        push(@html, "</pre>\n");
                    }
                    push(@html, "    </div>\n");
                }
            }
        }
    }
    push(@html, "    <h3><a hame=\"_prune\">Pruning logs</a></h3>\n");
    for my $logfile (sort { $b cmp $a } glob("$logs/prune-*.log")) {
        push(@html, "      <pre class=log>");
        open(L, "<$logfile") or die "ERROR: $logfile: $!\n";
        while(defined($_ = <L>)) {
            s/[\&<]/sprintf("&#%d;", ord(chr($1)))/ge;
            push(@html, $_);
        }
        close L;
        push(@html, "</pre>\n");
    }
    push(@html, "    <p>Generated ", (scalar localtime), ".\n");
    # TODO include tz
    if(defined $html) {
        (open(HTML, ">$html")
         and (print HTML @html)
         and (close HTML))
            or die "ERROR: creating $html: $!\n";
    }
    if(defined $email) {
        (open(MAIL, "|\Q$sendmail\E -t -oee -oi")
         and (print MAIL ("To: $email\n",
                          "Content-Type: text/html\n",
                          "Subject: $title\n",
                          "\n",
                          @html))
         and (close MAIL))
            or die "ERROR: creating $html: $!\n";
    }
}

print STDERR "$errors errors detected.\n" if $errors;
exit !!$errors;

=head1 RESTORING

Restore costs extra l-)

=head2 Manual Restore

The backup has the same layout, permissions etc as the original
system, so it's perfectly possible to simply copy files from a backup
directory to their proper location.

Be careful to get file ownership right.  The backup is stored with the
same I<numeric> user and group ID as the original system used.

=head2 Restoring With rsync

S<rsync -aSHz --numeric-ids /store/chymax/2010-04-01/users/rjk/. chymax:~rjk/.>

You could add the B<--delete> option if you wanted to restore to
exactly the status quo ante, or at the opposite extreme B<--existing>
if you only wanted to restore files that had been deleted.

You might prefer to rsync back into a staging area and then pick files
out manually.

=head2 Restoring with tar

You could tar up a backup directory (or a subset of it) and then untar
it on the target.  Remember to use the B<--numeric-owner> option to
tar.

=head1 MANAGING BACKUPS

The backup management tools are the HTML report; the "comfort"
settings; and the prune settings.

=head2 Report Contents

The HTML report contains the following information for each volume:

=over

=item

The date of the oldest complete backup.

=item

The number of complete backups.  This is green if there is a backup on
every known device and red if there any devices without backups.

=item

For each device, the date of the most recent backup to that device.
This is green if it is within the volume's B<max-age> parameter and
red otherwise.

=item

For each device, the number of backups on the device.  This is green
if positive and red if zero.

=item

Any nonempty logfiles.

=back

You should review the report regularly, and take action if there are
unexpected red cells.  If your B<max-age> setting is larger than your
offsite backup cycle time then you may expect to see red cells for the
offsite device(s).

=head2 Comfort Settings

For a volume that is supposed to be always available and backed up
daily, set B<max-age> to 0.  If it misses even one backup then it will
be marked in red in the report.

If you back up the volume less often then set a higher B<max-age>
accordingly.  For instance, a desktop system might be left on
overnight for backups just once a week.  In that case B<max-age>
would be set to 6.

If you only care about the most recent backup of a volume then set
B<prune-age> to 1.  Only the most recent complete backup will be kept.

If you want to be able to retrieve snapshots of old versions of a
volume, set B<prune-age> to the maximum distance back in time you want
to go.

=head2 Pruning

The B<--prune> option can be used to automatically delete old backups.
Any backup older than the B<prune-age> setting for the volume will be
delete (whether it is complete or not), with the exception that the
last backup for the volume will never be deleted.

B<--prune-incomplete> will delete I<incomplete> backups.  It
will still delete them even if they are less than B<prune-age> days
old.  It's suggested that this is only used manually if the number of
incomplete backups is getting out of hand.

B<--prune-unknown> will delete the logfiles for backups on unknown
devices.  Such devices are assumed to be lost.  If there any such
backups then B<--prune> and B<--prune-incomplete> will refuse to
operate.

=head2 Multiple Devices

It is possible to back up to more than one physical device.  For
instance, you might keep one device attached and the other off-site,
and periodically exchange them.

Each device must have separate device ID mention in the configuration
file and it its top-level I<device-id> file.

If you lost (or destroy) a device, you must remove it from the
configuration file.  Having done this you must use B<--prune-unknown>
to delete logs of backups to the lost device.

In this case the comfort settings apply to the total set of backups
across all the devices, not just the currently attached one.  This is
because it uses the log directory as its source of data, not the
contents of the devices.  This means that it would be possible for
pruning to delete I<all> the backups of a volume to a given device,
provided they were old enough and there were enough backups on other
devices.

Although it's possible to use a single B<store> directive and mount
each device at the same path (although not at the same time) it may be
more convenient to list all their possible mount points in separate
B<store> directives.  Then each device can have a separate mount point
and it won't be inconvenient to attach more than one of them
simultaneously.

Moreover, if the different devices have different mount points, it
will be possible to back up to all them in a single run.

=head2 Suggested Usage

A possible backup procedure is:

1. Create one or more devices and initialize them with unique device IDs.
Give each a separate mount point in I</etc/fstab> (or rely on your
auto-mounter to choose consistent paths for them).

2. Define each volume to be backed up in the configuration file, deciding
how many backups should be kept and how frequently they should be made.

3. Set up a cron job to perform backups nightly.

=over

=item

The cron job should definitely do B<--backup> B<--prune> in a single
command.  If you don't plan to manually retry failed backups add
B<--prune-incomplete>.

=item

The cron job could also add B<--html> in the same command, or it could
make it a separate command so that the report is still generated even
if the backup process fails completely.

=item

Don't include B<--prune-unknown> in the cron job.

=back

4. Inspect the report daily.  (For instance, have it emailed to you.)
Until the comfort settings are met, there will be red ink that you
cannot do anything about.

5. If you use multiple devices, rotate them according to some schedule
(e.g. weekly).

6. If you lose a device, delete its entry from the configuration file
and use B<--prune-unknown> to erase the associated logfiles.  Put a
replacement device I<with a new, unique device ID> into service as
soon as possible.

7. From time to time, do a manual restore test.

=head2 Other Hints

During setup, make liberal use of B<--verbose> and B<--dry-run> to see
what's going on.

Don't forgot to enable the cronjob after setup is complete and normal
operation has started.

=head1 FILES

=over

=item I</etc/rsbackup/config>

Configuration file.

=item I<LOGS/YYYY-MM-DD-DEVICE-HOST-VOLUME.log>

Log file for one attempt to back up a volume.

=item I<LOGS/prune-YYYY-MM-DD.log>

Log of recently pruning actions.

=item I<STORE/HOST/VOLUME/YYYY-MM-DD>

One backup for a volume.

=item I<STORE/HOST/VOLUME/YYYY-MM-DD.incomplete>

Exists while backup isn't (yet) complete.

=back

=head1 BUGS

B<--numeric-ids> is mandatory, and should be optional.

There is no support for concurrently backing up from multiple hosts.

The report should highlight when the most recent backup of a volume
failed.

There should be a plain text version of the report.

It should be possible to take disk space into account when pruning.

Space used on backup volumes should be included in the report.

=head1 AUTHOR

Richard Kettlewell <rjk@greenend.org.uk>

=cut
